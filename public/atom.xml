<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Song Wang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://swang251.github.io/"/>
  <updated>2018-10-22T04:45:29.000Z</updated>
  <id>http://swang251.github.io/</id>
  
  <author>
    <name>Song Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Reflection at Discontinuities</title>
    <link href="http://swang251.github.io/2018/10/21/Reflection-at-Discontinuities/"/>
    <id>http://swang251.github.io/2018/10/21/Reflection-at-Discontinuities/</id>
    <published>2018-10-22T03:58:25.000Z</published>
    <updated>2018-10-22T04:45:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>I got suddenly confused about how the reflection coefficient is computed, and it took me a whole night to figure out my mistake.</p><a id="more"></a><p>Consider such a case, when a wave is propagating, there is an abrupt discontinuity, which separates two different medium $M1$ and $M2$ to the left and right of the discontinuity point, respectively. The two medium has two different characteristic impedance $Z_1$ and $Z_2$. (It could also be the same media with different cross-section areas in a tube).</p><p>The pressure in $M1$ is decomposed into a right-going wave $p_1^+$ and a left-going wave $p_2^-$, which correspond to incident and reflection, respectively. So the right- and left-going volume flow rate are $\dfrac{p_1^+}{Z_1}$ and $-\dfrac{p_1^-}{Z_1}$. (the “$-$” sign means the left-going traveling direction) </p><p>Assuming the continuity of the pressure and the conservation of the volume flow at the boundary, we have:<br>$$p_1^+ + p_1^- = p_2^+ + p_2^-  \quad\quad (1)$$<br>and<br>$$\dfrac{p_1^+ - p_1^-}{Z_1} = \dfrac{p_2^+ - p_2^-}{Z_2}\quad\quad (2)$$</p><p><strong>From here the problem comes.</strong> I try to compute the reflection coefficient from the above two equations, but of course, I can’t get anything. <strong>This is because</strong> the reflection coefficient is not related to $Z_2$. Instead, it relates to the load impedance $Z_{load}$, e.g., the input impedance of the system to the right of the discontinuity point. So we will replace the eq. (1) and (2) by<br>$$p_1^+ + p_1^- = p_2   \quad\quad (3)$$<br>and<br>$$\dfrac{p_1^+ - p_1^-}{Z_1} = \dfrac{p_2}{Z_{load}} \quad\quad (4)$$.<br>This way, we get the reflection coefficient<br>$$R = \dfrac{Z_{load}-Z_1}{Z_{load}+Z_1} \quad\quad(5)$$</p><p><strong>Wait!</strong> But why I always see the reflection coefficient with two different characteristic impedances?<br><strong>The answer is,</strong> to calculate the reflection coefficient based on characteristic impedance, it is assumed that $p_2^-=0$, indicating an infinite length of $M2$ with no reflection or right-going wave. This way the input impedance of $M2$ is simply its characteristic impedance $Z_2$. Then we get<br>$$R = \dfrac{Z_2-Z_1}{Z_2+Z_1} \quad\quad(6)$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I got suddenly confused about how the reflection coefficient is computed, and it took me a whole night to figure out my mistake.&lt;/p&gt;
    
    </summary>
    
      <category term="Acoustics" scheme="http://swang251.github.io/categories/Acoustics/"/>
    
    
      <category term="Acoustics" scheme="http://swang251.github.io/tags/Acoustics/"/>
    
  </entry>
  
  <entry>
    <title>Descriptor and External Field of Palabos</title>
    <link href="http://swang251.github.io/2018/10/15/Palabos-Descriptor-External-Field/"/>
    <id>http://swang251.github.io/2018/10/15/Palabos-Descriptor-External-Field/</id>
    <published>2018-10-15T19:29:31.000Z</published>
    <updated>2018-10-15T21:03:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>For the lattice Boltzmann method, the descriptor has to be defined in advance. Here we briefly discuss the descriptor structure in Palabos. </p><a id="more"></a> <h2 id="Descriptor"><a href="#Descriptor" class="headerlink" title="Descriptor"></a>Descriptor</h2><p>In palabos, the descriptors are stored in <code>/src/latticeBoltzmann/nearestNeighborLatticesXD.h</code>, where $X=2,3$.</p><p>Each descriptor is a <strong>combination</strong> of the lattice schema and the external field, so that must inherit from at least two <em><code>DescriptorBase</code></em> including the basic  <em><code>DdQqDescriptorBase</code></em> defining the lattice-related variables, and a <em><code>EXTERNALVARLISTDescriptorBase</code></em> with external variables or <code>NoExternalFieldBase</code> if the problem involves no external variables. (<em><code>DdQqDescriptorBase</code></em> could be <code>D2Q9DescriptorBase</code>, and <em><code>EXTERNALVARLISTDescriptorBase</code></em> could be <code>RhoBarVelocityPiNeqOmegaDescriptorBase2D</code>).</p><ul><li><p>In <em><code>DdQqDescriptorBase</code></em>, it defines the <code>d</code>, the <code>q</code>, the lattice velocity <code>c[q][d]</code>, lattice weight <code>t[q]</code>, square speed of sound <code>cs2</code> and so on by means of <code>DdQqConstants</code>. </p></li><li><p>The <em><code>EXTERNALVARLISTDescriptorBaseXD</code></em> is written in <code>/src/latticeBoltzmann/externalFields.h</code>. In <em><code>EXTERNALVARLISTDescriptorBaseXD</code></em>, it defines the problem-specific <code>ExternalField</code> as <code>EXTERNALVARLISTDescriptorXD</code>. Here the <code>DdQq</code> of <code>EXTERNALVARLISTDdQqDescriptor</code> must correspond to the one in <code>DdQqDescriptorBase</code>. Here above <code>EXTERNALVARLIST-</code> represents the name list of the external variables, e.g., <code>EXTERNALVARLIST=RhoBarVelocityPiNeqOmega</code> and <code>EXTERNALVARLIST=ForcedRhoBarJ</code> for <code>RhoBarVelocityPiNeqOmegaD2Q9Descriptor</code> and <code>ForcedRhoBarJD2Q9Descriptor</code>, respectively.</p></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ul><li>Take the <code>RhoBarVelocityPiNeqOmegaD2Q9Descriptor</code> as an example to illustrate the structure, it inherits from <code>D2Q9DescriptorBase</code> and <code>RhoBarVelocityPiNeqOmegaDescriptorBase2D</code>. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; struct RhoBarVelocityPiNeqOmegaD2Q9Descriptor</span><br><span class="line">   : public D2Q9DescriptorBase&lt;T&gt;, </span><br><span class="line">     public RhoBarVelocityPiNeqOmegaDescriptorBase2D</span><br><span class="line">&#123;</span><br><span class="line">    static const char name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="DdQqDescriptorBase"><a href="#DdQqDescriptorBase" class="headerlink" title="DdQqDescriptorBase"></a>DdQqDescriptorBase</h3><ul><li><p>The <code>D2Q9DescriptorBase</code> is defined as </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; struct D2Q9DescriptorBase</span><br><span class="line">    : public D2Q9Constants&lt;T&gt;, public DefaultRoundOffPolicy&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef D2Q9DescriptorBase&lt;T&gt; BaseDescriptor;</span><br><span class="line">    enum &#123; numPop=D2Q9Constants&lt;T&gt;::q &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>where the lattce-related variables are defined in </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; struct D2Q9Constants</span><br><span class="line">&#123;</span><br><span class="line">    enum &#123; d = 2, q = 9 &#125;;        ///&lt; number of dimensions/distr. functions</span><br><span class="line">    static const T invD;          ///&lt; 1 / (number of dimensions)</span><br><span class="line">    static const int vicinity;    ///&lt; size of neighborhood</span><br><span class="line">    static const int c[q][d];     ///&lt; lattice directions</span><br><span class="line">    static const int cNormSqr[q]; ///&lt; norm-square of the vector c</span><br><span class="line">    static const T t[q];          ///&lt; lattice weights</span><br><span class="line">    static const T cs2;           ///&lt; lattice constant cs2 (in BGK, this is the square-speed-of-sound)</span><br><span class="line">    static const T invCs2;        ///&lt; 1 / cs2</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="EXTERNALVARLISTDescriptorBaseXD"><a href="#EXTERNALVARLISTDescriptorBaseXD" class="headerlink" title="EXTERNALVARLISTDescriptorBaseXD"></a>EXTERNALVARLISTDescriptorBaseXD</h3><ul><li><p>The <code>RhoBarVelocityPiNeqOmegaDescriptorBase2D</code> has a component <code>ExternalField</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct RhoBarVelocityPiNeqOmegaDescriptorBase2D &#123;</span><br><span class="line">    typedef RhoBarVelocityPiNeqOmegaDescriptor2D ExternalField;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>and the <code>RhoBarVelocityPiNeqOmegaDescriptor2D</code> would store</p><ul><li>the number of scalars,</li><li>the number of the species,</li><li>the index each variable starts,</li><li>the size of each variable (2 for 2d and 3 for 3d tensors),<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct RhoBarVelocityPiNeqOmegaDescriptor2D &#123;</span><br><span class="line">    static const int numScalars       = 7;</span><br><span class="line">    static const int numSpecies       = 4;</span><br><span class="line">    static const int rhoBarBeginsAt   = 0;</span><br><span class="line">    static const int sizeOfRhoBar     = 1;</span><br><span class="line">    static const int velocityBeginsAt = 1; </span><br><span class="line">    static const int sizeOfVelocity   = 2;</span><br><span class="line">    static const int piNeqBeginsAt    = 3;</span><br><span class="line">    static const int sizeOfPiNeq      = 3;</span><br><span class="line">    static const int omegaBeginsAt    = 6;</span><br><span class="line">    static const int sizeOfOmega      = 1;</span><br><span class="line">    static const int sizeOfForce      = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>meaning <code>ForcedRhoBarJdescriptor3DRhoBarVelocityPiNeqOmegaDescriptor2D</code> have 4 species including <code>rhoBar</code>, <code>velocity</code>, <code>piNeq</code> and <code>omega</code>, with 1, 2, 3 and 1 as the sizes, respectively. So the scalar number would be $1+2+3+1=7$ in total.</p></li></ul><h2 id="Setting-up-the-external-field"><a href="#Setting-up-the-external-field" class="headerlink" title="Setting up the external field"></a>Setting up the external field</h2><p>Once the descriptor with an external field is defined, the memory of <code>external</code> inside the <code>cell</code> is allocated (see <code>src/core/cell.h</code>). For initializing or simply setting values to the external field, one would use the data processor, i.e., <code>setExternalVector</code> or <code>setExternalScalar</code> with the variable start index like <code>DESCRIPTOR&lt;T&gt;::ExternalField::rhoBarBeginsAt</code>.</p><ul><li><p>An example of external force flow would be found in the project <code>/examples/showCases/womersley/</code>. Where the external forces is set by an array, i.e., the force is uniformally deployed in the domain.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array&lt;T,NSDESCRIPTOR&lt;T&gt;::d&gt; force(womersleyForce((T)0, amplitude, frequency, parameters),0.);</span><br><span class="line">setExternalVector(lattice,lattice.getBoundingBox(),NSDESCRIPTOR&lt;T&gt;::ExternalField::forceBeginsAt,force);</span><br></pre></td></tr></table></figure></li><li><p>For position-dependent external variables, one could use a <code>MultiScalarFieldXD</code> or <code>MultiTensorFieldXD</code>, initialized from a functional, as the input of <code>setExternalVector</code> or <code>setExternalScalar</code> and use a functional to initialize the <code>MultiXXXXFieldXD</code>. For the setup of the absorbing layers, I use</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MultiScalarField2D&lt;T&gt; sigma(lattice);</span><br><span class="line">WaveAbsorptionSigmaFunction2D&lt;T&gt; sigmaFunction2D(lattice.getBoundingBox(), numSpongeCells ,bulkValue);</span><br><span class="line">setToFunction(sigma, lattice.getBoundingBox(), sigmaFunction2D);</span><br><span class="line">setExternalScalar(lattice, lattice.getBoundingBox(),</span><br><span class="line">                      DESCRIPTOR&lt;T&gt;::ExternalField::sigmaBeginsAt, sigma );</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;For the lattice Boltzmann method, the descriptor has to be defined in advance. Here we briefly discuss the descriptor structure in Palabos. &lt;/p&gt;
    
    </summary>
    
      <category term="Palabos" scheme="http://swang251.github.io/categories/Palabos/"/>
    
    
      <category term="Palabos" scheme="http://swang251.github.io/tags/Palabos/"/>
    
      <category term="LBM" scheme="http://swang251.github.io/tags/LBM/"/>
    
      <category term="CFD" scheme="http://swang251.github.io/tags/CFD/"/>
    
  </entry>
  
  <entry>
    <title>3D Printing and Musical Instruments</title>
    <link href="http://swang251.github.io/2018/10/06/3D-Printer/"/>
    <id>http://swang251.github.io/2018/10/06/3D-Printer/</id>
    <published>2018-10-06T21:29:47.000Z</published>
    <updated>2018-10-15T19:27:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>3D printing is becoming more and more popular in a variety of areas and there are already many application in musical instruments. Here I will briefly talks about the main techniques and some of my preliminary attemps in printing a mouthpiece.</p><a id="more"></a><h2 id="3D-Printing-Techniques"><a href="#3D-Printing-Techniques" class="headerlink" title="3D Printing Techniques"></a>3D Printing Techniques</h2><p>This article deserves reading, <a href="https://all3dp.com/1/types-of-3d-printers-3d-printing-technology/" target="_blank" rel="noopener">All 10 Types of 3D Printing Technology in 2018 - All3DP</a>, inside which it classify the 3D printing techniques into, <em>material extrusion</em>, <em>vat polymerization</em>, <em>material jetting</em>, <em>binder jetting</em>, and <em>powder bed fusion (polymers or metals)</em>.</p><h3 id="Fused-Deposition-Modeling-FDM-Material-Extrusion"><a href="#Fused-Deposition-Modeling-FDM-Material-Extrusion" class="headerlink" title="Fused Deposition Modeling (FDM) - Material Extrusion"></a>Fused Deposition Modeling (FDM) - Material Extrusion</h3><p>The model is built layer by layer by the deposited materials which is melt through a nozzle in the extrusion head. The model is normally built from the bottom to the top.</p><h3 id="Stereolithography-Apparatus-SLA-Vat-Polymerization"><a href="#Stereolithography-Apparatus-SLA-Vat-Polymerization" class="headerlink" title="Stereolithography Apparatus (SLA) - Vat Polymerization"></a>Stereolithography Apparatus (SLA) - Vat Polymerization</h3><p>SLA is the earliest commercialized 3D printing technique. The 3D model is fabricated layer by layer from the liquid resin which is selectively solidified or polymerized by the ultraviolet (UV) rays through the lenses and the mirror. The object is normally built from the top to the bottom. A good introductory guide is provided by <a href="https://formlabs.com/blog/ultimate-guide-to-stereolithography-sla-3d-printing/" target="_blank" rel="noopener">Formlab</a>.</p><h3 id="Selective-Laser-Sintering-SLS-Power-Bed-Fusion"><a href="#Selective-Laser-Sintering-SLS-Power-Bed-Fusion" class="headerlink" title="Selective Laser Sintering (SLS) - Power Bed Fusion"></a>Selective Laser Sintering (SLS) - Power Bed Fusion</h3><p>SLS is similar to SLA. A thin layer of material powder is dispersed on the platform and preheated to the temperature just below the melting point. The the laser as the power source is used to sinter the materials (nylon or polymers). A good introductory guide is provided by <a href="https://formlabs.com/blog/what-is-selective-laser-sintering/#origins-sls" target="_blank" rel="noopener">Formlab</a>.</p><h3 id="PolyJet-Material-Jetting"><a href="#PolyJet-Material-Jetting" class="headerlink" title="PolyJet - Material Jetting"></a>PolyJet - Material Jetting</h3><p>PolyJet provide a faster and more accurate 3D printing compared with the techniques mentioned above. The print head deposits hundreds of tiny liquid droplets of the UV curable materials on the platform and the UV light attached to the print head simultaniously cures/solidifies the materials. A brief introduction could be found the <a href="http://www.stratasys.com/polyjet-technology" target="_blank" rel="noopener">Stratsys website</a> or the <a href="https://youtu.be/Som3CddHfZE" target="_blank" rel="noopener">introduction video</a> provided by Solid Concepts.</p><h3 id="Comparisons-between-them"><a href="#Comparisons-between-them" class="headerlink" title="Comparisons between them"></a>Comparisons between them</h3><ul><li><a href="https://www.cadimensions.com/blog/sla-vs-polyjet-need-know/" target="_blank" rel="noopener">SLA vs. PolyJet</a></li><li><a href="https://pinshape.com/blog/fdm-vs-sla-how-does-3d-printer-tech-work/" target="_blank" rel="noopener">FDM vs. SLA</a></li><li><a href="https://all3dp.com/fdm-vs-sla/" target="_blank" rel="noopener">FDM vs. SLA</a></li></ul><h2 id="3D-Printed-Musical-Instruments-the-real-functional-instruments-instead-of-the-ones-just-for-fun"><a href="#3D-Printed-Musical-Instruments-the-real-functional-instruments-instead-of-the-ones-just-for-fun" class="headerlink" title="3D Printed Musical Instruments - the real functional instruments instead of the ones just for fun"></a>3D Printed Musical Instruments - the real functional instruments instead of the ones just for fun</h2><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>Two of the 3D printed violins are <a href="https://www.3d-varius.com/" target="_blank" rel="noopener">3Dvarius</a>, the first electronic 3D printed violin inspired by Stradivarius and made by SLA, and <a href="http://www.hovalabs.com/hova-instruments/hovalin" target="_blank" rel="noopener">HOVALIN</a>, an open source 3D printable acoustic violin made by FDM.</p><h3 id="Brass-instruments"><a href="#Brass-instruments" class="headerlink" title="Brass instruments"></a>Brass instruments</h3><p><a href="http://jeromewiss.com/en/" target="_blank" rel="noopener">Jerome Wiss</a> use 3D printing for the prototype of his brass instruments.</p><h3 id="Saxophone-Mouthpiece"><a href="#Saxophone-Mouthpiece" class="headerlink" title="Saxophone Mouthpiece"></a>Saxophone Mouthpiece</h3><p>It is tested by Lorenzoni et al. (2013) that PolyJet is the best technique for 3D printing a mouthpiece. <a href="https://www.syos.co/en/" target="_blank" rel="noopener">SYOS</a> is using FDM for making customized mouthpiece. </p><p>Personnaly, I have tried both FDM (Ultimaker 2+/3)and SLA (Form2) in 3D printing a saxophone mouthpiece. SLA provides a better resolution with an easier operation while you have to play with hundreds of parameters to print an acceptable mouthpiece by FDM. Such parameters might include:</p><ul><li>Resolution</li><li>Nozzle sizes</li><li>Layer thickness</li><li>Line width</li><li>Infilling</li><li>Ironing</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref."></a>Ref.</h2><ul><li><a href="https://www.syos.co/en/blog/lab/3-d-printing-musical-instruments" target="_blank" rel="noopener">3D printing: future of the music instrument making? - Syos Blog</a></li><li><a href="https://www.3dnatives.com/en/top-15-3d-printing-music210620174/" target="_blank" rel="noopener">TOP 15 3D Printed Music Instruments &amp; Music Applications</a></li><li><a href="http://www.3ddayin.net/fuwu/3Ddayinbaike/23932.html" target="_blank" rel="noopener">常见三种3D打印技术：FDM、SLS、SLA技术原理</a></li><li><a href="http://www.cnpowdertech.com/2017/kejifazhan_0327/20974.html" target="_blank" rel="noopener">20张动图秒懂SLA、CLIP、3DP、PolyJet和FDM 3D打印原理</a></li><li><a href="https://www.quora.com/How-does-a-Form2-3D-printer-compare-to-an-Ultimaker2+-What-is-the-failure-rate-and-how-much-maintenance-is-needed" target="_blank" rel="noopener">How does a Form2 3D printer compare to an Ultimaker2+? What is the failure rate and how much maintenance is needed?-Quora</a></li><li>Lorenzoni, Valerio, E. L. Doubrovski, and J. C. Verlinden. 2013. “Embracing the Digital in Instrument Making: Towards a Musician-Tailored Mouthpiece by 3D Printing.” In Proceedings of the Stockholm Music Acoustics Conference 2013, SMAC 2013, Stockholm (Sweden), 30 July-3 August, 2013.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3D printing is becoming more and more popular in a variety of areas and there are already many application in musical instruments. Here I will briefly talks about the main techniques and some of my preliminary attemps in printing a mouthpiece.&lt;/p&gt;
    
    </summary>
    
      <category term="Research Daily" scheme="http://swang251.github.io/categories/Research-Daily/"/>
    
    
      <category term="Research Daily" scheme="http://swang251.github.io/tags/Research-Daily/"/>
    
      <category term="CAML" scheme="http://swang251.github.io/tags/CAML/"/>
    
  </entry>
  
  <entry>
    <title>SSH connection to a Cluster</title>
    <link href="http://swang251.github.io/2018/10/04/Passwordless-SSH-connection-to-a-Cluster/"/>
    <id>http://swang251.github.io/2018/10/04/Passwordless-SSH-connection-to-a-Cluster/</id>
    <published>2018-10-04T19:10:09.000Z</published>
    <updated>2018-10-06T21:33:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>I am using the cluster <a href="https://docs.computecanada.ca/wiki/Graham" target="_blank" rel="noopener">GRAHAM</a> for our simulation, and it uses SSH (Secure Shell) to connect to the remote servers. It is found annoying to type the password everytime you try to log in or copy files from the server. Herewith several simple commands, we could domake the password-less connection (for MacOS only).</p><a id="more"></a><ol><li><code>cd ~/.ssh/</code>, enter the folder where the ssh keys are kept.</li><li><code>ssh-keygen -t rsa</code>, create a new ssh key pair. You would be asked to<br><code>Enter file in which to save the key:</code> and I use <code>graham</code> here.</li><li><code>ssh-add -K graham</code>, add the ssh private key to the ssh-agent to store the passphrase the keychain.</li><li><code>cat graham.pub &gt;&gt; authorized_keys</code>, write the public key into the file authorized_keys.</li><li><code>ssh-copy-id -i graham.pub USER@graham.computecanada.ca</code>, <code>ssh-copy-id</code> is to use locally available keys to authorize logins on a remote machine. The authorized_keys is copied to the cluster.</li></ol><p><strong>Done!</strong></p><p>PS: add <code>alias graham=&#39;ssh -y USER@graham.comoputecanada.ca&#39;</code> into <code>~./bash_profile</code> for convenience</p><h3 id="Userful-links"><a href="#Userful-links" class="headerlink" title="Userful links"></a>Userful links</h3><ul><li><a href="https://www.ssh.com/ssh/key/" target="_blank" rel="noopener">SSH Key</a></li><li><a href="https://www.msri.org/realvideo/ln/msri/usered/ssh/bernstein/1/7.html" target="_blank" rel="noopener">SSH Files</a></li><li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">Github Help</a></li><li><a href="https://docs.computecanada.ca/wiki/SSH" target="_blank" rel="noopener">Compute Canada Wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I am using the cluster &lt;a href=&quot;https://docs.computecanada.ca/wiki/Graham&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GRAHAM&lt;/a&gt; for our simulation, and it uses SSH (Secure Shell) to connect to the remote servers. It is found annoying to type the password everytime you try to log in or copy files from the server. Herewith several simple commands, we could domake the password-less connection (for MacOS only).&lt;/p&gt;
    
    </summary>
    
      <category term="Research Daily" scheme="http://swang251.github.io/categories/Research-Daily/"/>
    
    
      <category term="Research Daily" scheme="http://swang251.github.io/tags/Research-Daily/"/>
    
      <category term="CAML" scheme="http://swang251.github.io/tags/CAML/"/>
    
      <category term="HPC" scheme="http://swang251.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>LBM-based Solver</title>
    <link href="http://swang251.github.io/2018/09/17/LBM-based-Solver/"/>
    <id>http://swang251.github.io/2018/09/17/LBM-based-Solver/</id>
    <published>2018-09-17T21:04:05.000Z</published>
    <updated>2018-09-17T22:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is simply a list of different Lattice Boltzmann Method-based solvers.</p><a id="more"></a><h2 id="Palabos"><a href="#Palabos" class="headerlink" title="Palabos"></a><a href="http://palabos.org" target="_blank" rel="noopener">Palabos</a></h2><ul><li>Short for “PArallel LAttice BOltzmann Solver”,</li><li>“Palabos” = “παλαβός” in Greek, meaning “Crazy”</li><li>Developed by <a href="https://www.flowkit.com/" target="_blank" rel="noopener">FlowKit Ltd. technology company</a></li><li>Supported by <a href="http://spc.unige.ch/doku.php" target="_blank" rel="noopener">Scientific and Parallel Computing Group (SPC)</a> at the University of Geneva.</li><li>A fork from OpenLB</li><li>Written in C++ with no external dependencies (only Posix and MPI). It also provides additional programmer interfaces for the Python and Java.</li></ul><h2 id="OpenLB"><a href="#OpenLB" class="headerlink" title="OpenLB"></a><a href="http://www.openlb.net/" target="_blank" rel="noopener">OpenLB</a></h2><ul><li>Developed by the <a href="http://www.lbrg.kit.edu/" target="_blank" rel="noopener">Lattice Boltzmann Research Group</a> at Karlsruhe Institute of Technology, which is led by Dr. Mathias J. Krause.</li><li>The <a href="http://www.openlb.net/authors" target="_blank" rel="noopener">author list</a></li></ul><h2 id="XFlow-CFD"><a href="#XFlow-CFD" class="headerlink" title="XFlow CFD"></a><a href="https://www.3ds.com/products-services/simulia/products/xflow/" target="_blank" rel="noopener">XFlow CFD</a></h2><ul><li>A SIMULIA product.</li><li>Using MRT-CM and Wall-Modeled Large Eddy Simulation (WMLES) for simulation.</li><li>The <a href="https://www.youtube.com/watch?v=dN92l2gp6lc" target="_blank" rel="noopener">co-simulation with Abaqus</a> sounds cool.</li></ul><h2 id="PowerFlow"><a href="#PowerFlow" class="headerlink" title="PowerFlow"></a><a href="https://exa.com/en/product/simulation-tools/powerflow-cfd-simulation" target="_blank" rel="noopener">PowerFlow</a></h2><ul><li>A product of <a href="https://exa.com/en" target="_blank" rel="noopener">Exa Corporation</a> which is acquired by Dassault Systèmes on November 17 (<a href="https://exa.com/en/message-our-customers" target="_blank" rel="noopener">news here</a>) and becomes part of SIMULIA, a Dassault Systèmes brand.</li><li><a href="https://exa.com/en/company/cfd-simulation-resources" target="_blank" rel="noopener">Demo video and literature</a> could be found in the link.</li><li><a href="https://exa.com/en/company/exa-lattice-boltzmann-technology" target="_blank" rel="noopener">Technology</a> including very large eddy simulation (VLES).</li></ul><h2 id="ProLB"><a href="#ProLB" class="headerlink" title="ProLB"></a><a href="http://www.prolb-cfd.com/" target="_blank" rel="noopener">ProLB</a></h2><ul><li>A recently (maybe) built solver, one of whose creators is Prof. Pierre Sagaut.</li><li>Especially for aeroacoustic and aerodynamic simulation of weakly compressible flow.</li><li>The <a href="http://www.prolb-cfd.com/technology/" target="_blank" rel="noopener">technology</a> includes double relaxation time (DRT) for collision, wall-modeled large eddy simulation (WMLES) for turbulence modeling, immersed boundary model (IBM) for boundary conditions.</li></ul><p>PS: </p><ul><li><a href="https://www.3ds.com/" target="_blank" rel="noopener">Dassault Systèmes</a> , a subsidiary of Dassault Group, is a CAE/PLM software developing company whose subsidiaries including SIMULIA and SolidWorks. <a href="https://www.3ds.com/products-services/simulia/" target="_blank" rel="noopener">SIMULIA</a> products include Abaqus, XFLOW CFD, and now also PowerFlow.</li><li>Just forget me if anything description is wrong.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is simply a list of different Lattice Boltzmann Method-based solvers.&lt;/p&gt;
    
    </summary>
    
      <category term="Palabos" scheme="http://swang251.github.io/categories/Palabos/"/>
    
    
      <category term="Palabos" scheme="http://swang251.github.io/tags/Palabos/"/>
    
      <category term="LBM" scheme="http://swang251.github.io/tags/LBM/"/>
    
      <category term="CFD" scheme="http://swang251.github.io/tags/CFD/"/>
    
      <category term="OpenLB" scheme="http://swang251.github.io/tags/OpenLB/"/>
    
      <category term="XFlow" scheme="http://swang251.github.io/tags/XFlow/"/>
    
      <category term="PowerFlow" scheme="http://swang251.github.io/tags/PowerFlow/"/>
    
      <category term="ProLB" scheme="http://swang251.github.io/tags/ProLB/"/>
    
  </entry>
  
  <entry>
    <title>Selective Filter 2D - Palabos</title>
    <link href="http://swang251.github.io/2018/09/15/Selective-Filter-2D-Palabos/"/>
    <id>http://swang251.github.io/2018/09/15/Selective-Filter-2D-Palabos/</id>
    <published>2018-09-16T03:36:17.000Z</published>
    <updated>2018-09-16T04:52:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>I just implemented the 2D selective filter<sup>1</sup> in Palabos. Because of the non-local calculation when filtering the collision operator, it takes Miguel and me some time to think about a way to implement it in Palabos. </p><ul><li><p>We first thought about the <code>integrateProcessingFunctional</code> but it might only do the post-collision operation (though we could apply a -1 <code>level</code> and call <code>executeInternalProcessors(-1)</code> manually). </p></li><li><p>Then Miguel found the <em>DynamicProcessor</em> could be a candidate,something in <em>src/basicDynamics/dynamicsProcessorXD.hh</em> where there is <code>ExternalRhoJcollideAndStream2D</code> for external macroscopic variable cases (<em>examples/codesByTopic/externalMacroscopicVariables</em>). </p></li><li><p>I then found the <code>nonLocalDynamicsXD</code> written in <em>src/core/nonLocalDynamicsXD.h/hh</em>. This doesn’t seems to be complete and neither is there a show case. However, you can find something related in <code>ExecuteNonLocalDynamics3D</code>, a functional inherited from <code>BoxProcessingFunctional3D_L</code> in <em>src/boundaryCondition/NLD_boundaries3D.h/hh</em>. </p></li></ul><p>I finally decide to go to the last direction because I consider <code>nonLocalDynamicsXD</code> as a good interface to start with. So, the basic idea here is to keep every variables and function of the dynamics in the <code>dynamics</code> class and create each member function a functional for data processor. Likely, I write <code>SelectiveFilterBGKDynamics2D.nonLocalAction()</code> and <code>SelectiveFilterBGKDynamics2D.prepareFNeq()</code> and two functional inherited from <code>BoxProcessingFunctional2D_L</code>. In addition, the dynamics class has two private members for the original and the filtered $f_{neq}$. <code>applyProcessingFunctional</code> would be used in the main function.</p><p>One important thing I found when writing a new dynamics is about the <code>serialize</code> and <code>unserialize</code>. I do need write <code>serializer.addValues()</code> and <code>unserializer.readValues()</code> for each member variables or there would be a problem. I don’t get it totally understand it but hopefully, <a href="https://isocpp.org/wiki/faq/serialization" target="_blank" rel="noopener">this article</a> would help, and I will be back with the answer soon.</p><ol><li>Ricot, Denis, Simon Marié, Pierre Sagaut, and Christophe Bailly. 2009. “Lattice Boltzmann Method with Selective Viscosity Filter.” Journal of Computational Physics 228 (12): 4478–4490.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I just implemented the 2D selective filter&lt;sup&gt;1&lt;/sup&gt; in Palabos. Because of the non-local calculation when filtering the collision oper
      
    
    </summary>
    
      <category term="Palabos" scheme="http://swang251.github.io/categories/Palabos/"/>
    
    
      <category term="Palabos" scheme="http://swang251.github.io/tags/Palabos/"/>
    
      <category term="LBM" scheme="http://swang251.github.io/tags/LBM/"/>
    
      <category term="CFD" scheme="http://swang251.github.io/tags/CFD/"/>
    
  </entry>
  
  <entry>
    <title>Setup tips for NI hardware + DAQ Toolbox on Matlab + Windows XP (SP3)</title>
    <link href="http://swang251.github.io/2018/09/11/daqplot-windowsxp-caml/"/>
    <id>http://swang251.github.io/2018/09/11/daqplot-windowsxp-caml/</id>
    <published>2018-09-12T02:19:12.000Z</published>
    <updated>2018-09-14T20:05:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Working on old version software and hardware is not as easy and direct as it seems to be. I am recently trying to set up the Dantec Dynamics CTA hot-wire anemometer. Because the software could only run on Windows XP or other versions in the same era, I have to install Windows XP on the PC of our lab. </p><p>This blog writes about the setup on Windows XP (SP3) 32-bit for the NI PCI-4472 data acquisition board and DaqPlot, a program for data acquisition and analysis written by Gary P. Scavone and is a simplified version of DataLogger by James Woodhouse.</p><ul><li>The latest release of Matlab for Windows XP (SP3) 32-bit is R2015b (<a href="https://www.mathworks.com/support/sysreq/previous_releases.html" target="_blank" rel="noopener">details here</a>);</li><li>The earliest release of Matlab (or Data Acquisition Toolbox) supporting NI PCI-4472 is R2014a (<a href="https://www.mathworks.com/hardware-support/nidaqmx.html" target="_blank" rel="noopener">details here</a>);</li><li>The latest release of NI-DAQmx supporting Windows XP (SP3) 32-bit is NI-DAQmx 15.5.1;</li><li>The earliest release of NI-DAQmx for NI PCI-4472 required by Data Acquisition Toolbox on Matlab is NI-DAQmx 9.0 (or 9.1);</li><li>Check <a href="https://www.mathworks.com/help/daq/troubleshooting-tips.html" target="_blank" rel="noopener">troubleshooting tips</a> for Data Acquisition Toolbox when needed, e.g. the comments recommended <code>daq.getVendors</code> and <code>daq.getDevices</code>.</li></ul><p>In addition,</p><ul><li>The latest StreamWare for Dantec Dynamics CTA system supporting NI-DAQmx driver is StreamWare v3.40 SP4.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Working on old version software and hardware is not as easy and direct as it seems to be. I am recently trying to set up the Dantec Dynam
      
    
    </summary>
    
      <category term="Research Daily" scheme="http://swang251.github.io/categories/Research-Daily/"/>
    
    
      <category term="Research Daily" scheme="http://swang251.github.io/tags/Research-Daily/"/>
    
      <category term="CAML" scheme="http://swang251.github.io/tags/CAML/"/>
    
  </entry>
  
  <entry>
    <title>Palabos Dynamics Calling Relationships</title>
    <link href="http://swang251.github.io/2018/09/10/Palabos-Dynamics-Calling-Relationships/"/>
    <id>http://swang251.github.io/2018/09/10/Palabos-Dynamics-Calling-Relationships/</id>
    <published>2018-09-10T19:59:43.000Z</published>
    <updated>2018-09-10T20:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>In this article, the calling relationship of dynamics would be shown which helps write your own dynamic classes. The dynamics classes are mainly written in <em>/src/basicDynamics/</em> and <em>/src/complexDynamics/</em>. Here we will take <code>BGKdynamics</code> and <code>MRTdynamics</code> as examples for illustration.</p><h3 id="BGKdynamics"><a href="#BGKdynamics" class="headerlink" title="BGKdynamics"></a>BGKdynamics</h3><ul><li>The calling graph: <code>BGKdynamics::collide()</code> &lt;– <code>dynamicsTemplates::bgk_ma2_collision()</code> &lt;– <code>dynamicsTemplatesImpl::bgk_ma2_collision()</code>.</li><li>The declaration and implementation of functions in class <code>BGKdynamics</code> are in <em>src/basicDynamics/isoThermalDynamics.h</em> and <em>../isoThermalDynamics.hh</em>, respectively.</li><li>The structs <code>dynamicsTemplates</code> and <code>dynamicsTemplatesImpl</code> and the two member functions with the same name <code>bgk_ma2_collision()</code> are written in <em>src/latticeBoltzmann/dynamicsTemplates.h</em></li></ul><h3 id="MRTdynamics"><a href="#MRTdynamics" class="headerlink" title="MRTdynamics"></a>MRTdynamics</h3><ul><li>The calling graph: <code>MRTdynamics::collide()</code> &lt;– <code>mrtTemplates::mrtCollision()</code> &lt;– <code>mrtTemplatesImpl::mrtCollision()</code>.</li><li>The declaration and implementation of functions in class <code>MRTdynamics</code> are in <em>src/complexDynamics/mrtDynamics.h</em> and <em>../mrtDynamics.hh</em>, respectively.</li><li>The structs <code>mrtTemplates</code> and <code>mrtTemplatesImpl</code> and the two member functions with the same name <code>mrtCollision()</code> are written in <em>src/latticeBoltzmann/mrtTemplates.h</em></li></ul><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><ul><li>The kernal function is the <code>XXXdynamics::collide()</code> which implements the collision step.</li><li>The <code>collide()</code> would call different computations from different <code>Templates</code> like <code>dynamicsTemplates</code>, <code>mrtTemplates</code>, <code>momentTemplates</code> and so on.</li><li>The <code>collide()</code> is implemented on <code>cell</code> level. So for non-local dynamics, a superclass <code>class NonLocalDynamics2D : public CompositeDynamics&lt;T,Descriptor&gt;</code> might be used.</li></ul><p>To better understand the calling relations, one could use <a href="https://romanegloo.wordpress.com/2012/03/29/generating-a-callgraph-by-using-doxygen-and-graphviz-13/" target="_blank" rel="noopener">Doxygen+GraphViz</a> to plot the call graph or get use of the structure or call graph/hierachy function within IDE.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In this article, the calling relationship of dynamics would be shown which helps write your own dynamic classes. The dynamics classes are
      
    
    </summary>
    
      <category term="Palabos" scheme="http://swang251.github.io/categories/Palabos/"/>
    
    
      <category term="Palabos" scheme="http://swang251.github.io/tags/Palabos/"/>
    
      <category term="LBM" scheme="http://swang251.github.io/tags/LBM/"/>
    
      <category term="CFD" scheme="http://swang251.github.io/tags/CFD/"/>
    
  </entry>
  
  <entry>
    <title>The guide for the Data Processor structure of Palabos</title>
    <link href="http://swang251.github.io/2018/08/28/The-guide-for-the-Data-Processor-structure-of-Palabos/"/>
    <id>http://swang251.github.io/2018/08/28/The-guide-for-the-Data-Processor-structure-of-Palabos/</id>
    <published>2018-08-29T03:49:02.000Z</published>
    <updated>2018-08-29T04:20:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>In this article, the running and calling sequences of the data processors related functions is briefly summarized, based on the <a href="http://www.palabos.org/documentation/userguide/data-processors.html" target="_blank" rel="noopener">official documentation</a>. Mainly six ‘layers’ are mentioned here.</p><h3 id="First-two-kinds-of-data-processors-are-used"><a href="#First-two-kinds-of-data-processors-are-used" class="headerlink" title="First, two kinds of data processors are used:"></a>First, two kinds of data processors are used:</h3><ul><li><strong>applyProcessingFunctional</strong>, the wrapper for <code>excuteDataProcessor</code>: is executed just once, on one or more blocks</li><li><strong>integrateProcessingFunctional</strong>, the wrapper for <code>addInternalProcessor</code>:  is added to a block and is part of the block and can be executed as many times as wished, blabla. The added processors are implicitly (to the users) called by the function <em>executeInternalProcessors</em></li></ul><h3 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h3><ul><li>The function <code>integrateProcessingFunctional</code> and <code>applyProcessingFunctional</code> are defined and implemented in <em>/src/multiBlock/multiDataProcessorWrapper2D.h/hh</em>.</li><li>The <em>/src/atomicBlock/dataProcessorWrapperXD.h/hh</em> stores the atomic Block version.</li><li>The function <code>applyProcessingFunctional</code> has three main parameters: 1) <code>BoxProcessingFunctionalXD_LSTN functional</code>, 2) <code>BoxXD domain</code> and, 3) <code>MultiBlockLatticeXD lattice</code>;</li><li>The function <code>integrateProcessingFunctional</code> has an additional parameter: <code>plint level</code>;</li></ul><h3 id="Third"><a href="#Third" class="headerlink" title="Third"></a>Third</h3><ul><li><code>applyProcessingFunctional</code> calls <code>excuteDataProcessor(BoxProcessorGeneratorXD(functional, domain), lattice);</code></li><li><code>integrateProcessingFunctional</code> calls <code>addInternalProcessor(BoxProcessorGeneratorXD(functional, domain), lattice, level);</code></li><li>So the <code>BoxProcessorGeneratorXD</code> has no difference for the two wrapper functions.</li></ul><h3 id="Fourth"><a href="#Fourth" class="headerlink" title="Fourth"></a>Fourth</h3><ul><li>the <code>excuteDataProcessor</code> and <code>addInternalProcessor</code> are defined and implemented in <em>/src/multiBlock/multiBlockOperationsXD.h/.cpp</em></li><li>Both functions has the parameter <code>DataProcessorGeneratorXD const&amp; generator</code></li><li>one of the overriden of the functions is the kernel one.</li><li>The kernel  <code>excuteDataProcessor</code>  and <code>addInternalProcessor</code> finally calls the corresponding atomicBlock versions which is defined and implemented in <em>/src/atomicBlock/atomicBlockOperationsXD.h/.cpp</em></li></ul><h3 id="Fifth-in-the-atomicBlock-versions"><a href="#Fifth-in-the-atomicBlock-versions" class="headerlink" title="Fifth, in the atomicBlock versions"></a>Fifth, in the atomicBlock versions</h3><ul><li><em>/src/atomicBlock/atomicBlockOperationsXD.h/.cpp</em></li><li>the kernel <code>excuteDataProcessor</code> calls the <code>processor -&gt; process()</code> where <code>processor</code> is a <code>DataProcessorXD</code> defined in <em>/src/atomicBlock/dataProcessingFunctionalXD.h/.cpp</em></li><li>the kernel <code>addInternalProcessor</code> calls the <code>actor.integrateDataProcessor</code>, where the <code>actor</code> is an <code>AtomicBlockXD</code> written in <em>/src/atomicBlock/atomicBlockXD.h/.cpp</em>, inside which the <code>integrateDataProcessor</code> runs <code>processors[level].push_back(processor)</code>;</li></ul><h3 id="Sixth"><a href="#Sixth" class="headerlink" title="Sixth"></a>Sixth</h3><ul><li><code>DataProcessorXD</code>  &lt;== <code>BoxProcessorXD</code> who overrides the function <code>process()</code> runing <code>functional -&gt; processGenericBlock(domain, atomicBlocks)</code> where <code>BoxProcessingFunctionalXD* functional</code> is written in the file <em>/src/atomicBlock/dataProcessingFunctionalXD.cpp</em></li><li><strong>BoxProcessingFunctionalXD</strong> is a base class defined in the same file which <strong>has many subclasses for different purposes</strong>.</li><li>The <code>processGenericBlock</code> calls the <code>process</code> function in the tons of subclasses functionals of the class <code>BoxProcessingFunctionalXD</code>, like <code>NTensorFieldBoxProcessingFunctional3D</code> or <code>BoxProcessingFunctionalXD_LL</code></li><li>The <code>process()</code> would be finally overriden by the subclasses of <code>BoxProcessingFunctionalXD_LL</code> or so, and implemented. likely in <code>class TurbulentLatticeToPassiveAdvDiff3X : public BoxProcessingFunctionalXD_LL</code> in <em>/src/multiPhysics/advectionDiffusion3D.h/.hh</em></li><li><code>SpecialFunctional</code> ==&gt; <code>BoxProcessingFunctionalXD_LL</code> etc.  ==&gt; <code>BoxProcessingFunctionalXD</code></li></ul><h3 id="In-addition-about-excuteInternalProcessors"><a href="#In-addition-about-excuteInternalProcessors" class="headerlink" title="In addition, about excuteInternalProcessors()"></a>In addition, about <code>excuteInternalProcessors()</code></h3><ul><li>It is called in 1) <code>MultiBlockLatticeXD::stream()</code>, 2) <code>MultiBlockLatticeXD::collideAndStream()</code> and 3) <code>MultiBlockXD::initialize()</code></li><li>The <code>MultiBlockXD::executeInternalProcessors(level)</code> calls the <code>getComponent(blockId).excuteInternalProcessors(leve)</code> which is at the atomicBlocks unit. (line511@<em>/arc/multiBlock/multiBlock3D.cpp</em>)</li><li>The <code>AtomicBlockXD::executeInternalProcessors(level, processors)</code> finally calls the processors -&gt; process(); in (line254@<em>/src/atomicBlock/atomicBlock3D.cpp</em>)</li></ul><h3 id="An-example"><a href="#An-example" class="headerlink" title="An example"></a>An example</h3><p><em>/examples/showCases/boussinesqThermal2d/rayleighBenard2D.cpp</em></p><ul><li>line 171:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">applyProcessingFunctional (</span><br><span class="line">            new IniTemperatureRayleighBenardProcessor2D&lt;T,NSDESCRIPTOR,ADESCRIPTOR&gt;(parameters), </span><br><span class="line">            adLattice.getBoundingBox(),  adLattice );</span><br></pre></td></tr></table></figure><p>where the <code>Struct IniTemperatureRayleighBenardProcessor2D : public BoxProcessingFunctional2D_L&lt;T,adDescriptor&gt;</code> is a functional</p><ul><li>line 293: </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integrateProcessingFunctional (new BoussinesqThermalProcessor2D&lt;&gt;(), nslattice.getBoundingBox(), nslattice, adLattice, processorlevel );</span><br></pre></td></tr></table></figure><p>where the <code>class BoussinesqThermalProcessor2D : BoxProcessingFunctional2D_LL</code> is a functional defined and implemented in <em>/src/multiPhysics/boussinesqThermalProcessor2D.h/.hh</em>.</p><p><strong>NOTA:</strong> the code used here is Palabos version 2.0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In this article, the running and calling sequences of the data processors related functions is briefly summarized, based on the &lt;a href=&quot;
      
    
    </summary>
    
      <category term="Palabos" scheme="http://swang251.github.io/categories/Palabos/"/>
    
    
      <category term="Palabos" scheme="http://swang251.github.io/tags/Palabos/"/>
    
      <category term="LBM" scheme="http://swang251.github.io/tags/LBM/"/>
    
      <category term="CFD" scheme="http://swang251.github.io/tags/CFD/"/>
    
  </entry>
  
  <entry>
    <title>Practical Vocal Acoustics Ch3 Vocal Resonance</title>
    <link href="http://swang251.github.io/2018/08/12/Practical-Vocal-Acoustics-Ch3-Vocal-Resonance/"/>
    <id>http://swang251.github.io/2018/08/12/Practical-Vocal-Acoustics-Ch3-Vocal-Resonance/</id>
    <published>2018-08-12T13:36:38.000Z</published>
    <updated>2018-08-12T13:37:34.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Voice" scheme="http://swang251.github.io/categories/Voice/"/>
    
    
      <category term="Voice" scheme="http://swang251.github.io/tags/Voice/"/>
    
      <category term="Practical Vocal Acoustics" scheme="http://swang251.github.io/tags/Practical-Vocal-Acoustics/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Song Wang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://swang251.github.io/"/>
  <updated>2019-02-15T10:08:21.747Z</updated>
  <id>http://swang251.github.io/</id>
  
  <author>
    <name>Song Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Digital Audio Signal Processing Lecture 5 (Notes)</title>
    <link href="http://swang251.github.io/2019/02/05/Digital-Audio-Signal-Processing-Lecture-5/"/>
    <id>http://swang251.github.io/2019/02/05/Digital-Audio-Signal-Processing-Lecture-5/</id>
    <published>2019-02-05T23:00:52.000Z</published>
    <updated>2019-02-15T10:08:21.747Z</updated>
    
    <content type="html"><![CDATA[<p>Notes of Digital Audio Signal Processing, Lecture 5. <a id="more"></a></p><h3 id="convolution-and-multiplication">Convolution and multiplication</h3><ul><li><span class="math inline">\(Z(f)=X(f)Y(f)\leftrightarrow z=x*y\)</span></li><li><span class="math inline">\(Z(f)=X(f)*Y(f)\leftrightarrow z=xy\)</span></li><li>Application in Source-Filter model</li></ul><h3 id="parsevals-theorem"><a href="https://en.wikipedia.org/wiki/Parseval%27s_theorem" target="_blank" rel="noopener">Parseval's theorem</a></h3><p><span class="math display">\[\sum\limits_{n=-\infty}^\infty x^2[n]= \dfrac{1}{2\pi}\int_{-\pi}^{\pi}|X(e^{j\hat{\omega}})|^2\text{d}\hat{\omega}=\int_{-\frac{1}{2}}^{\frac{1}{2}}|X(f)|^2\text{d}f,\]</span> where the <span class="math inline">\(|X(f)|^2\)</span> is called the power spectral <strong>density</strong> which is with respect to frequency.</p><ul><li>To prove:<ul><li>Given signal and its DTFT <span class="math inline">\(x\leftrightarrow X\)</span></li><li>For the time reversed version of <span class="math inline">\(x\)</span>, <span class="math inline">\(y[n] = x[-n] \leftrightarrow Y(f)=\overline{X}(f)\)</span></li><li>For signal <span class="math inline">\(z\)</span> whose DTFT is defined as <span class="math inline">\(Z(f)=X(f)Y(f) = X(f)\overline{X}(f)\)</span>. <span class="math inline">\(z=x*y\)</span></li><li>In time domain: <span class="math inline">\(z[n]=\sum\limits_{k\in\mathbb{Z}}x[k]y[n-k] = \sum\limits_{k\in\mathbb{Z}}x[k]x[k-n]\)</span>, where <span class="math inline">\(\sum\limits_{k\in\mathbb{Z}}x[k]x[k-n]\)</span> is the <a href="https://en.wikipedia.org/wiki/Autocorrelation" target="_blank" rel="noopener">autocorrelation</a>. When <span class="math inline">\(n=0\)</span>, <span class="math display">\[\begin{equation}z[0]=\sum_\limits{k\in\mathbb{Z}}x^2[k]\label{Parseval1}\end{equation}\]</span>.</li><li>Taking the inverse DTFT: <span class="math inline">\(z[n] = \int_{-\frac{1}{2}}^{\frac{1}{2}}Z(f)e^{2\pi jfn}\text{d}f = \int_{-\tfrac{1}{2}}^{\tfrac{1}{2}}X(f)Y(f)e^{2\pi jfn}\text{d}f\)</span>. When <span class="math inline">\(n=0\)</span>, <span class="math display">\[\begin{equation}z[0]=\int_{-\frac{1}{2}}^{\frac{1}{2}}|X(f)|^2\text{d}f\label{Parseval2}\end{equation}\]</span>.</li><li>Eq. <span class="math inline">\(\eqref{Parseval1}\)</span> = Eq. <span class="math inline">\(\eqref{Parseval2}\)</span>.</li></ul></li></ul><h3 id="symmetry-properties-of-signal-and-related-spectral-properties.">Symmetry properties of signal and related spectral properties.</h3><ul><li>Even: <span class="math inline">\(x_e[n]=x_e[-n]\)</span></li><li>Odd: <span class="math inline">\(x_o[n]=-x_o[-n]\)</span></li><li>properties:<ul><li><span class="math inline">\(x_e\bot x_o\)</span>, (<span class="math inline">\(\sum x[n]y[n]=0\)</span>, dot product equals zero)</li><li><span class="math inline">\(\text{odd}\times\text{even} = \text{even}\)</span></li></ul></li><li>For any signal, it could be decomposed as into an even signal and an odd signal, meaning, <span class="math inline">\(x[n] = x_e[n]+x_o[n]\)</span>, where <span class="math inline">\(x_e[n] = \frac{x[n]+x[-n]}{2}\)</span> and <span class="math inline">\(x_o[n] = \frac{x[n]-x[-n]}{2}\)</span></li><li>Apply it into Fourier transform <span class="math display">\[ \begin{align}    X(f) &amp;= \sum\limits_{n\in\mathbb{Z}}x[n]e^{-2\pi jfn}\\         &amp;= \sum\limits_{n\in\mathbb{Z}}(x_e[n]+x_o[n])(\cos 2\pi fn - j \sin2\pi fn)\\         &amp;= \sum\limits_{n\in\mathbb{Z}}(x_e[n]\cos2\pi fn - jx_o[n]\sin2\pi fn),\\ \end{align}\]</span> where <strong>the <span class="math inline">\(\Re{\{X(f)\}}\)</span> is even and the <span class="math inline">\(\Im{\{X(f)\}}\)</span> is odd. </strong><ul><li>So a real spectrum means the even signal and a pure imaginary spectrum corresponds to a odd signal.</li></ul></li></ul><h3 id="frequency-shift-and-modulation">Frequency shift and modulation</h3><ul><li><span class="math inline">\(z=xp_{f_0}\)</span> (<span class="math inline">\(z[n]=x[n]e^{2\pi jf_0n}\)</span>)</li><li>Its Fourier transform: <span class="math inline">\(Z(f) = X*P_{f_0}=X(f-f_0)\)</span>, where <span class="math inline">\(P_{f_0}(f)=\delta(f-f_0)=\delta_{f_0}(f)\)</span></li><li><strong>Periodic in one domain</strong> means <strong>evenly spaced in the other domain</strong>.</li><li><a href="https://en.wikipedia.org/wiki/Dirac_comb" target="_blank" rel="noopener">Dirac comb</a></li></ul><h3 id="derivative-of-a-spectrum">Derivative of a Spectrum</h3><ul><li><span class="math display">\[\begin{align}    \dfrac{\text{d} X(f)}{\text{d} f}        &amp;= \frac{\text{d} \sum\limits_{n\in\mathbb{Z}}x[n]e^{-2\pi jfn}}{\text{d} f}\\       &amp;= -2\pi j \sum\limits_{n\in\mathbb{Z}}nx[n]e^{-2\pi jfn}\end{align}\]</span></li><li>Application: <strong>gain</strong><ul><li><span class="math inline">\(x[n] \rightarrow y[n] = g[n]x[n]\)</span>, where <span class="math inline">\(g[n] = a+bn\)</span> is a gain, linearly evolves over time.</li><li><span class="math inline">\(y[n]=ax[n]+b(nx[n])\)</span> <span class="math inline">\(\leftrightarrow\)</span> <span class="math inline">\(Y(f) = aX(f)+\frac{bj}{2\pi}\frac{\text{d} X(f)}{\text{d}f}\)</span>.</li><li><strong>gain in time</strong> <span class="math inline">\(\leftrightarrow\)</span> <strong>derivative in spectrum</strong></li><li><strong>Further explanation?</strong></li></ul></li></ul><h3 id="time-scaling">Time scaling</h3><ul><li><span class="math inline">\(y(t)=x(\alpha t)\)</span> <span class="math inline">\(\leftrightarrow\)</span> <span class="math inline">\(Y = \frac{1}{\alpha}X(\frac{f}{\alpha})\)</span></li></ul><h3 id="discrete-time-system">Discrete-time system</h3><ul><li>A system: <span class="math inline">\(y=\mathcal{T}\{x\}\)</span> or <span class="math inline">\(y[n] = \mathcal{T}\{x\}[n]\)</span></li><li>Like delay (<span class="math inline">\(y[n]=x[n-n_0]\)</span>), square (<span class="math inline">\(y[n]=x^2[n]\)</span>), moving max, threshold and so on.</li><li><strong>Distortion - Chebyshev polynomials?</strong></li><li><strong>Noise reduction need distortion?</strong></li></ul><h4 id="classes">classes</h4><ul><li>memoryless: only the current time (no past, no future samples);</li><li>linear: additivity and scalability</li><li>time invariance: the system propcessing doesn't depends on when you apply it (<span class="math inline">\(y[n-{n_0}]=\mathcal{T}\{x[n-{n_0}]\}\)</span>)</li><li>Stability: <span class="math inline">\(\lVert x\rVert &lt; B_x\)</span> <span class="math inline">\(\leftrightarrow\)</span> <span class="math inline">\(\lVert y\rVert &lt; B_y\)</span>.<ul><li>delay: stable</li><li>amplifier: stable</li><li>accumulator: dependsf</li></ul></li></ul><h3 id="linear-time-invariant-system-leftrightarrow-filter">Linear Time-Invariant system <span class="math inline">\(\leftrightarrow\)</span> filter</h3><ul><li>A filter is a LTI system.</li><li><span class="math inline">\(x[n] = \sum\limits_{k\in\mathbb{Z}}x[k]\delta[n-k]\)</span> <span class="math display">\[\begin{align}  y[n] &amp;= \mathcal{T}\{x\}[n] \\       &amp;= \mathcal{T}\{\sum\limits_{k\in\mathbb{Z}}x[k]\delta_k[n]\}\\       &amp;= \sum\limits_{k\in\mathbb{Z}}\mathcal{T}\{x[k]\delta_k[n]\}\\       &amp;= \sum\limits_{k\in\mathbb{Z}}\{x[k]\mathcal{T}\{\delta_k[n]\}\} \quad \text{applying linearities}\\       &amp;= \sum\limits_{k\in\mathbb{Z}}x[k]h_k[n],  \end{align}\]</span> where <span class="math inline">\(h_k=\mathcal{T}\{\delta_k\}\)</span> is the <strong>impulse reponse</strong>.</li><li><span class="math inline">\(y=x*h\)</span></li><li><span class="math inline">\(Y=XH\)</span>, where <span class="math inline">\(H\)</span> is the Fourier transform of <span class="math inline">\(h\)</span> and is the frequency response.</li><li><a href="https://en.wikipedia.org/wiki/Toeplitz_matrix#Discrete_convolution" target="_blank" rel="noopener">Toeplitz matrix and convolution</a></li><li>For convoluion: <span class="math inline">\(N_y = N_x+N_h-1\)</span></li><li>Properties:<ul><li>Stability: depends on <span class="math inline">\(h\)</span>, meaning the bound of <span class="math inline">\(\sum\limits_{k\in\mathbb{Z}}|h[n-k]|\)</span></li><li>causality: <span class="math inline">\(h[n-k]=0\)</span> for <span class="math inline">\(k\leq n\)</span>.</li><li>memoryless: <span class="math inline">\(h[k]=0\)</span> when <span class="math inline">\(k\neq 0\)</span></li></ul></li></ul><h3 id="notable-notes">Notable notes</h3><ul><li>Energy: the accumulated version of the power <span class="math inline">\(x^2[n]\)</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes of Digital Audio Signal Processing, Lecture 5.
    
    </summary>
    
      <category term="DSP" scheme="http://swang251.github.io/categories/DSP/"/>
    
    
      <category term="Lecture Notes (DASP)" scheme="http://swang251.github.io/tags/Lecture-Notes-DASP/"/>
    
  </entry>
  
  <entry>
    <title>Commands and Routine of Simulation on Graham, a Compute Canada Cluster</title>
    <link href="http://swang251.github.io/2019/01/30/Commands-and-Routine-of-Simulation-on-Graham-Compute-Canada-Cluster/"/>
    <id>http://swang251.github.io/2019/01/30/Commands-and-Routine-of-Simulation-on-Graham-Compute-Canada-Cluster/</id>
    <published>2019-01-30T10:41:19.000Z</published>
    <updated>2019-01-31T03:57:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Again, I am using the cluster <a href="https://docs.computecanada.ca/wiki/Graham" target="_blank" rel="noopener">GRAHAM</a> for the simulation and here is the routine I normally use in the cluster end for my project. <a id="more"></a></p><h3 id="login-and-version-control">Login and Version Control</h3><ul><li>For convenience, I make an alias of the ssh connection called <code>graham</code>. Details could be check in the <a href="https://swang251.github.io/2018/10/04/Passwordless-SSH-connection-to-a-Cluster/">previous blog</a>.</li><li>I am using <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> and <a href="https://bitbucket.org/" target="_blank" rel="noopener">Bitbucket</a> for version control.</li></ul><h3 id="compilation">Compilation</h3><ul><li>For the LBM simulation, I got my projects stored in the folder <em>lbm</em> and the Palabos library in <em>palabos</em>, make sure they are in the same directory level.</li><li>I am using <a href="https://cmake.org/" target="_blank" rel="noopener">CMake</a> for cross-platform compiling. I use CMake because my laptop for a preliminary test is MacBook with MacOS but the cluster will always be Linux.</li><li>I got two folders <em>cmake-build-debug</em> for locally compiling and <em>cmake-cluster</em> for the cluster end.</li><li>The local version is built using CLion, everything is straightforward. On the cluster end, go to the folder <em>cmake-cluster</em> and use the command <code>cmake ../</code></li><li>Sometimes, we need to manually load cmake module. Use <code>module avail cmake</code> to check the available cmake version and use, e.g., <code>module load cmake/3.12.3</code> to load the new cmake version.</li></ul><h3 id="running-jobs">Running Jobs</h3><ul><li><p>For each project, there will be a corresponding batch file <em>**.sh</em>. For example <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#SBATCH --account=def-SUPERVISOR</span><br><span class="line">#SBATCH --time=01:00:00</span><br><span class="line">#SBATCH --ntasks=64</span><br><span class="line">#SBATCH --mem-per-cpu=128M</span><br><span class="line">#SBATCH --job-name=JOBNAME</span><br><span class="line">#SBATCH --output=%x-%j-np64.out</span><br><span class="line"></span><br><span class="line">mpirun -np 64 ./projectName</span><br></pre></td></tr></table></figure></p></li><li>make sure everything is included<ul><li>output directory created (or automatically created)</li><li>program parameters</li><li>have the modified code compiled (<code>make</code>)</li></ul></li><li>submit the job: <code>sbatch ./projectName.sh</code><ul><li>you will see <em>Submitted batch job 11315557</em></li></ul></li><li>job status: <code>squeue -u $USER</code><ul><li>you will see <em>JOBID USER ACCOUNT NAME ST START_TIME TIME_LEFT NODES CPUS GRES MIN_MEM NODELIST (REASON)</em></li></ul></li><li>cancel job: <code>scancel JobID</code></li><li>check the efficiency of the job: <code>seff JobID</code></li><li><p>The information of the submitted job, including the output, would be written in the <em>.out</em> files.</p></li></ul><h3 id="file-transfer">File transfer</h3><ul><li>File transfer is normally done by <a href="https://www.globus.org/" target="_blank" rel="noopener">Globus</a>, details can be found <a href="https://docs.computecanada.ca/wiki/Globus" target="_blank" rel="noopener">here</a></li></ul><h3 id="cpu-based-paraview-client-server-visualization">CPU-based ParaView client-server visualization</h3><p>For large data processing, it will be more convenient to handle it on the cluster end, making use of ParaView cliend-server mechanisms.</p><ul><li>check the <a href="https://docs.computecanada.ca/wiki/Visualization#CPU-based_ParaView_client-server_visualization_on_general_purpose_clusters" target="_blank" rel="noopener">Compute Canada Documentation Wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Again, I am using the cluster &lt;a href=&quot;https://docs.computecanada.ca/wiki/Graham&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GRAHAM&lt;/a&gt; for the simulation and here is the routine I normally use in the cluster end for my project.
    
    </summary>
    
      <category term="Research Daily" scheme="http://swang251.github.io/categories/Research-Daily/"/>
    
    
      <category term="Research Daily" scheme="http://swang251.github.io/tags/Research-Daily/"/>
    
      <category term="CAML" scheme="http://swang251.github.io/tags/CAML/"/>
    
      <category term="HPC" scheme="http://swang251.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>Digital Audio Signal Processing Lecture 4 (Notes)</title>
    <link href="http://swang251.github.io/2019/01/29/Digital-Audio-Signal-Processing-Lecture-4/"/>
    <id>http://swang251.github.io/2019/01/29/Digital-Audio-Signal-Processing-Lecture-4/</id>
    <published>2019-01-29T22:38:43.000Z</published>
    <updated>2019-02-02T04:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Notes of Digital Audio Signal Processing, Lecture 4.</p><p>NOTA: All <span class="math inline">\(f\)</span> in this blog refers to the normalized frequency. <a id="more"></a></p><h3 id="different-representation">Different representation</h3><h4 id="time-domain-representation">Time-domain representation</h4><ul><li><span class="math inline">\(\delta_k\)</span>: the feature of time, representing time 'k';</li><li><span class="math inline">\(x = \sum\limits_{k\in\mathbb{Z}} x[k]\delta_k\)</span> or <span class="math inline">\(x[n] = \sum\limits_{k\in\mathbb{Z}}x[k]\delta[n-k]\)</span></li></ul><h4 id="frequency-domain-representation-spectrum">Frequency-domain representation (spectrum)</h4><ul><li><span class="math inline">\(p_f[n] = e^{2\pi jfn}\)</span>: the feature of frequency, and be used to represent <span class="math inline">\(x[n]\)</span> in terms of frequency <span class="math inline">\(f\)</span>.</li><li><span class="math inline">\(x[n]\)</span> is a linear combination of <span class="math inline">\(p_f[n]\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(x[n] = \int X(f)p_f[n]\text{d}f\)</span>, where <span class="math inline">\(X(f)\)</span> is the Fourier representation.</li></ul><h3 id="heuristic-description-of-fourier-transform">Heuristic description of Fourier Transform</h3><h4 id="for-xn-aejtheta">For <span class="math inline">\(x[n] = ae^{j\theta}\)</span></h4><ul><li><span class="math inline">\(x[n]p_{f_0}[n] = ae^{j(2\pi f_0n+\theta)}\)</span><ul><li><span class="math inline">\(\sum\limits_{n\in\mathbb{Z}} a\cos(2\pi f_0n+\theta) = a\cos\theta\delta(f_0)\)</span>,</li><li><span class="math inline">\(\sum\limits_{n\in\mathbb{Z}} a\sin(2\pi f_0n+\theta) = a\sin\theta\delta(f_0)\)</span>,</li><li>so <span class="math display">\[\begin{equation} \sum\limits_{n\in\mathbb{Z}} ae^{j\theta}p_{f_0}n = ae^{j\theta}\delta(f_0),\end{equation}\label{distribution}\]</span> where <span class="math inline">\(\delta(f_0)\)</span> is a distribution function</li></ul></li></ul><h4 id="for-xn-aejthetae2pi-f_0n">For <span class="math inline">\(x[n] = ae^{j\theta}e^{2\pi f_0n}\)</span></h4><ul><li><span class="math inline">\(x[n]p_{-f}[n] = ae^{j\theta}e^{2\pi j(f_0-f)n}\)</span><ul><li>Looking for a modulated frquency <span class="math inline">\(f_{modulated} = f_0-f\)</span>.</li><li>So we have, <span class="math display">\[\begin{equation}\sum\limits_{n\in\mathbb{Z}} x[n]p_{-f}[n] = ae^{j\theta}\delta(f_0-f),\end{equation}\]</span> meaning there is a contribution of <span class="math inline">\(x[n]\)</span> only when <span class="math inline">\(f_0 = f\)</span>.</li></ul></li><li>Go for, <span class="math inline">\(\sum\limits_{n\in\mathbb{Z}} x[n]p_{-f}[n]\)</span> = <span class="math inline">\(\sum\limits_{n\in\mathbb{Z}} x[n]\overline{p_f[n]} = \mathbf{x}\cdot\mathbf{p_f} = \mathbf{p_f}^H\cdot\mathbf{x}\)</span>, assuming <span class="math inline">\(\mathbf{x}\)</span> is a real vector (signal).<ul><li>Meaning <strong>projecting signal <span class="math inline">\(\mathbf{x}\)</span> onto the coordinate <span class="math inline">\(\mathbf{p_f}\)</span></strong>,</li><li>where it first does the modulation (<span class="math inline">\(e^{-2\pi jfn}\)</span>) and then the summation (<span class="math inline">\(\sum\)</span>)</li><li>Properties of the Euclidean Inner Product: <span class="math inline">\(\mathbf{u}\cdot\mathbf{v} = \overline{\mathbf{v}\cdot\mathbf{u}}\)</span></li></ul></li><li><strong>Fourier transform and inverse Fourier transform</strong><ul><li><span class="math inline">\(X(f)=\sum\limits_{n\in\mathbb{Z}}x[n]e^{-2\pi jfn}\)</span>: the &quot;-&quot; sign comes from the conjugate of <span class="math inline">\(\mathbf{p_f}\)</span> during the dot products</li><li><span class="math inline">\(x[n]=\int X(f)e^{+2\pi jfn}\text{d}f\)</span>: the &quot;+&quot; sign because these is the linear combination of $</li></ul></li></ul><h3 id="more-about-fourier-transform">More about Fourier Transform</h3><ul><li>Fourier Transform: <span class="math inline">\(X(f) = \int x(t)e^{-2\pi jFt}\text{d}t\)</span>.</li><li>Discrete-time Fourier Transform: <span class="math inline">\(X(f) = \sum\limits_{n\in \mathbb{Z}}x[n]e^{-2\pi jfn}\)</span>.</li><li>The frequency is real and continuous.</li><li><span class="math inline">\(X(f) \in \mathbb{C}\)</span> is periodic and complex.</li><li>Though it is easy to prove, but <strong>why does sampling make signal periodic in frequency domain?</strong><ul><li><span class="math inline">\(X(f) = X(f+1)\)</span></li></ul></li><li>Convergence: <span class="math inline">\(|X(f)|\)</span>. (<a href="https://en.wikipedia.org/wiki/Norm_(mathematics)" target="_blank" rel="noopener">norm</a>)</li></ul><h3 id="examples">Examples</h3><table style="width:51%;"><colgroup><col style="width: 22%"><col style="width: 29%"></colgroup><thead><tr class="header"><th style="text-align: center;">Time-domain <span class="math inline">\(x[n]\)</span></th><th style="text-align: center;">Frequency-domain <span class="math inline">\(X(f)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Impulse: <span class="math inline">\(\delta[n]\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td></tr><tr class="even"><td style="text-align: center;">Damped exponential: <span class="math inline">\(a^n u[n]\)</span></td><td style="text-align: center;"><span class="math inline">\(\dfrac{1}{1-ae^{-2\pi jf}}\)</span></td></tr><tr class="odd"><td style="text-align: center;">Rectangular function: <span class="math inline">\(r_N[n]=u[n]-u[n-N]\)</span></td><td style="text-align: center;"><span class="math inline">\(e^{-\pi jf(N-1)}\dfrac{\sin(\pi fN)}{\sin(\pi f)}\)</span></td></tr></tbody></table><ul><li><strong>NOTA:</strong> For the rectangular function, the <span class="math inline">\(\dfrac{\sin(\pi fN)}{\sin(\pi f)}\)</span> in the <span class="math inline">\(X(f)\)</span> is not the sinc function. Instead, <span class="math inline">\(\dfrac{\sin(\pi f)}{\pi f} = \text{sinc}(\pi f)\)</span>, the sinc function, which is non-periodic, is the Fourier transform of the rectangular function instead of its DTFT. The sampling makes the <span class="math inline">\(X(f)\)</span> periodic in frequency domain as shown in the table.</li></ul><h3 id="theorems">Theorems</h3><ul><li>periodic in <span class="math inline">\(f\)</span></li><li>linear</li><li>time-shift (delay): <span class="math inline">\(y[n] = x[n-d] \rightarrow Y(f) = X(f)e^{-2\pi jfd}\)</span></li><li>frequency-shift: <span class="math inline">\(y[n] = x[n]e^{2\pi jf_0n} \rightarrow Y(f) = X(f-f_0)\)</span></li><li>time-reverse: <span class="math inline">\(y[n] = x[-n] \rightarrow Y(f)=X(-f)\)</span></li><li>Frequency multiplication means time convolution and vice versa.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes of Digital Audio Signal Processing, Lecture 4.&lt;/p&gt;
&lt;p&gt;NOTA: All &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; in this blog refers to the normalized frequency.
    
    </summary>
    
      <category term="DSP" scheme="http://swang251.github.io/categories/DSP/"/>
    
    
      <category term="Lecture Notes (DASP)" scheme="http://swang251.github.io/tags/Lecture-Notes-DASP/"/>
    
  </entry>
  
  <entry>
    <title>Digital Audio Signal Processing-Lecture 3 (Notes)</title>
    <link href="http://swang251.github.io/2019/01/22/Digital-Audio-Signal-Processing-Lecture-3/"/>
    <id>http://swang251.github.io/2019/01/22/Digital-Audio-Signal-Processing-Lecture-3/</id>
    <published>2019-01-22T22:15:58.000Z</published>
    <updated>2019-02-13T20:01:28.298Z</updated>
    
    <content type="html"><![CDATA[<p>Notes of Digital Audio Signal Processing, Lecture 3. <a id="more"></a></p><ul><li>From now on, the hat, <span class="math inline">\(\hat{}\)</span>, represents the normalized version.</li></ul><h3 id="notable-notes">Notable Notes</h3><ul><li>von Coler et al. 2018, Parametric Synthesis of Glissando Note Transitions - A User Study in a Real-Time Application, DAFx-18.</li><li>signal: a mathematical function that carries information, could be pressure, control parameters and so on.</li><li>Lagrange polynomial used in spatial sampling, non-integer delay as an interpolating filter.</li><li>A delay system is a system.</li><li>ADSR is a synthesizer.</li><li><span class="math inline">\(s[n] = \sum\limits_{k\in \mathbb{Z}}s[k]\delta[n-k]\)</span></li><li><strong>Dirac delta function</strong><ul><li>There are many ways to define Dirac delta function, see <a href="http://mathworld.wolfram.com/DeltaFunction.html" target="_blank" rel="noopener">Wolfram MathWorld</a></li><li>See more <a href="http://tutorial.math.lamar.edu/Classes/DE/DiracDeltaFunction.aspx" target="_blank" rel="noopener">here</a></li><li>integral, kind of dot product.</li></ul></li><li><strong>Block by Block (buffer)</strong> in applications equals <strong>vectorization</strong></li><li><strong>Sampling</strong> makes the spectrum periodic<ul><li>For two frequency, <span class="math inline">\(\hat{f_0}\)</span> and <span class="math inline">\(\hat{f_0}+r\)</span><ul><li>Discrete-time domain: <span class="math inline">\(\cos(2\pi\hat{f_0}n) = \cos(2\pi(\hat{f_0}+r)n)\)</span>, because <span class="math inline">\(2\pi r n\)</span> is an integer multiple of <span class="math inline">\(2\pi\)</span>, so it is periodic inthe frequency domain.</li><li>Continuous-time domain: <span class="math inline">\(\cos(2\pi f_0 t) \neq \cos(2\pi (f_0+rf_0)t)\)</span></li></ul></li><li>From <span class="math inline">\(x(t)=x(t+T_0)\)</span> to <span class="math inline">\(x[n] = x[n+N_0]\)</span>, it only works when $N_0 = k $ and <span class="math inline">\(k=0,1,\dots, N_0\)</span></li></ul></li><li>impulse (time-domain) <span class="math inline">\(\rightarrow\)</span> 1 (frequency-domain) <span class="math inline">\(\rightarrow\)</span> alias filter (works as a bandlimited filter) <span class="math inline">\(\rightarrow\)</span> rectangular (frequency-domain) <span class="math inline">\(\rightarrow\)</span> ADC <span class="math inline">\(\rightarrow\)</span> sinc function (time-domain)</li><li>The basis of Fourier transform is simply rotating vectors in the 2D plane (<span class="math inline">\(e^{2\pi j\hat{f_0}n}\)</span>)</li></ul><h3 id="discrete-time-sequences">Discrete-time sequences</h3><h4 id="impulse">Impulse</h4><p><span class="math display">\[\begin{equation}  \delta[n] =     \begin{cases}      1, \quad n=0,\\      0, \quad n\neq0    \end{cases}  \end{equation}\]</span></p><ul><li>Delayed impulse: <span class="math inline">\(\delta_{n_0}[n]=\delta[n-n_0]\)</span></li><li>Impulse response</li></ul><h4 id="unit-step-sequence">Unit step sequence</h4><p><span class="math display">\[\begin{equation}  u[n] =     \begin{cases}      1, \quad n\leq0,\\      0, \quad n&lt;0    \end{cases}  \end{equation}\]</span></p><ul><li><span class="math inline">\(u[n]=u[n-1]+\delta[n]=\sum\limits_{k=0}^\infty\delta[n-k]\)</span></li><li>works as a switch (control)</li><li>used to check the stability</li></ul><h4 id="rectangular-sequence">Rectangular sequence</h4><p><span class="math display">\[\begin{equation}r[n]=u[n]-u[n-N],\end{equation}\]</span> where <span class="math inline">\(N\)</span> is the length of the rectangular</p><ul><li><span class="math inline">\(r[n] = \delta[n]\)</span> when <span class="math inline">\(N=1\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math display">\[\delta[n]=u[n]-u[n-1],\]</span> which is also explained as a finite-difference scheme, representing the slope the signal is we divide both sides by the sampling time $ T_s$</li><li>used to design waveforms like a square wave (a linear combination of rectangular sequence)</li></ul><h4 id="damped-exponentials">Damped Exponentials</h4><p><span class="math display">\[\begin{equation}  x[n] =     \begin{cases}      Aa^n, \quad n\leq0,\\      0, \quad n&lt;0    \end{cases}  \end{equation}\]</span></p><ul><li><span class="math inline">\(0&lt;a&lt;1\)</span>, damped signal, <span class="math inline">\(-1&lt;a&lt;0\)</span>, damped osillating signal.</li><li><a href="https://en.wikipedia.org/wiki/RC_circuit" target="_blank" rel="noopener"><strong>RC circuit</strong></a> and <a href="https://en.wikipedia.org/wiki/Low-pass_filter#RC_filter" target="_blank" rel="noopener">RC filter</a>, working as a low pass filter, check <a href="https://www.electronics-tutorials.ws/filter/filter_2.html" target="_blank" rel="noopener">here</a>.</li><li>The frequency response of <span class="math inline">\(a^nu[n]\)</span> is <span class="math inline">\(\dfrac{1}{1-ae^{-j\hat{\omega}}}\)</span>, where <span class="math inline">\(\hat{\omega}\)</span> is the normalized radian frequency.</li><li>recursive</li></ul><h4 id="sinusoids-sequence">Sinusoids sequence</h4><p><span class="math display">\[\begin{equation}x[n] = A_0\cos(2\pi \hat{f_0}n+\phi_0),\end{equation}\]</span> where <span class="math inline">\(\hat{f_0}\)</span> is the normalized frequency and <span class="math inline">\(\phi_0\)</span> is the initial phase.</p><ul><li>recursive computaion of <span class="math inline">\(sin\)</span> functions</li></ul><h4 id="complex-exponential-sequence">Complex exponential sequence</h4><p><span class="math display">\[P_{f_0}[n]=e^{2\pi j \hat{f_0}n}\]</span> and <span class="math display">\[z[n] = A_0e^{j\phi_0}e^{j2\pi\hat{f_0}n}=z[n-1]e^{2\pi j \hat{f_0}},\]</span> where the phasor <span class="math inline">\(\hat{A}=Ae^{j\phi_0}\)</span> is the complex amplitude.</p><h4 id="damped-sinusoids">Damped sinusoids</h4><p><span class="math display">\[x[n] = A_0e^{-\alpha n}\cos(2\pi\hat{f_0}n+\phi_0)\]</span> and <span class="math display">\[z[n] = \hat{A_0}e^{-\alpha+2\pi j\hat{f_0}n},\]</span> where <span class="math inline">\(e^{-\alpha}\)</span> represents the damping.</p><h3 id="the-link-between-phase-shift-and-time-delay">The link between phase shift and time delay</h3><p>Comparing: <span class="math display">\[x(t) \rightarrow x(t-d)\]</span> and <span class="math display">\[sin(2\pi f_0t+\phi_0) \rightarrow sin(2\pi f_0 (t-d)+\phi_0),\]</span> where the phase shift <span class="math inline">\(-2\pi f_0 d\)</span> is frequency dependent.</p><h3 id="others">Others</h3><h4 id="spatial-wave">spatial wave</h4><p><span class="math display">\[p(t,r) = A_0\cos(2\pi f_0(t-\frac{r}{c}))\]</span> - the link between the spatial domain and the phase domain - wavenumber is the spatial frequency of the wave <span class="math inline">\(k = \dfrac{2\pi f_0}{c}=\dfrac{2\pi}{\lambda}\)</span> (radians or circle per unit distance), BTW, <strong>wavenumber is not dimensionless</strong> but Helmholtz number <span class="math inline">\(ka\)</span> is. - Compared to frequency <span class="math inline">\(\omega = \dfrac{2\pi}{T}\)</span>, where <span class="math inline">\(T\)</span> and <span class="math inline">\(\lambda\)</span> are the length of the period in time and space, respectively.</p><h4 id="phasor">Phasor</h4><ul><li>phasor <span class="math inline">\(\leftrightarrow\)</span> vector</li></ul><h4 id="linear-chirp">Linear chirp</h4><p><span class="math display">\[\phi[n] = \phi_0 + 2\pi(\hat{f_0}+\frac{\beta(n+1)}{2})n\]</span> instead of simply <span class="math inline">\(\phi[n] = \phi_0+2\pi f[n]n\)</span>, where <span class="math inline">\(f[n] = \hat{f_0}+\beta n\)</span></p><ul><li>this is to maintain the phase continuity.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes of Digital Audio Signal Processing, Lecture 3.
    
    </summary>
    
      <category term="DSP" scheme="http://swang251.github.io/categories/DSP/"/>
    
    
      <category term="Lecture Notes (DASP)" scheme="http://swang251.github.io/tags/Lecture-Notes-DASP/"/>
    
  </entry>
  
  <entry>
    <title>Digital Audio Signal Processing-Lecture 2 (Notes)</title>
    <link href="http://swang251.github.io/2019/01/15/Digital-Audio-Signal-Processing-Lecture-2/"/>
    <id>http://swang251.github.io/2019/01/15/Digital-Audio-Signal-Processing-Lecture-2/</id>
    <published>2019-01-16T00:15:03.000Z</published>
    <updated>2019-02-01T06:29:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Notes of Digital Audio Signal Processing, Lecture 2. <a id="more"></a></p><h2 id="dot-product">Dot product</h2><ul><li><span class="math inline">\(D(\mathbf{u},\mathbf{v})=\sum_{i=1}^3u_iv_i\)</span></li><li>The <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence#Definition" target="_blank" rel="noopener">correlation</a> is related to dot product, see <a href="https://qr.ae/TUnqvl" target="_blank" rel="noopener">here</a>.</li><li>norm (<span class="math inline">\(\left\lVert\mathbf{u}\right\rVert = D(\mathbf{u},\mathbf{u})=\sum_{i=1}^3u_i^2\)</span>) <span class="math inline">\(\rightarrow\)</span> dot product (<span class="math inline">\(D(\mathbf{u},\mathbf{v})=\sum_{i=1}^3u_iv_i\)</span>) <span class="math inline">\(\rightarrow\)</span> Energy <span class="math inline">\(\left\lVert\mathbf{u}\right\rVert ^2\)</span>.</li><li><span class="math inline">\(D(\mathbf{u},\mathbf{u}) = \mathbf{u}^\intercal \mathbf{u}\)</span></li><li>inner product</li><li>Signal in discrete time of lenght <span class="math inline">\(N\)</span> has a dimension of <span class="math inline">\(N\)</span>;</li><li><a href="https://en.wikipedia.org/wiki/Orthogonality" target="_blank" rel="noopener">Orthogonal</a> <span class="math inline">\(\mathbf{s_1}^\intercal \mathbf{s_2} = 0\)</span>, meaning, nonzeros in <span class="math inline">\(\mathbf{s_1}\)</span> correspond to zeros in <span class="math inline">\(\mathbf{s_2}\)</span> <span class="math inline">\(\rightarrow\)</span> <strong>Frequency does not overlap ??</strong></li></ul><h2 id="matrix">Matrix</h2><ul><li>A matrix is a system.</li><li><a href="https://en.wikipedia.org/wiki/Hadamard_matrix" target="_blank" rel="noopener"><strong>Hadamard matrix</strong></a> <span class="math inline">\(\rightarrow\)</span> <a href="https://en.wikipedia.org/wiki/Hadamard_transform" target="_blank" rel="noopener">Hadamard Transform</a> is an example of a generalized class of Fourier transform.</li><li><a href="https://en.wikipedia.org/wiki/Rotation_matrix" target="_blank" rel="noopener"><strong>Rotation matrix</strong></a></li><li>In Matlab, <code>u.*v</code> equals <code>diag(u)*v</code>, where <code>diag(u)</code> is the <strong>temporal envelope</strong>.</li><li>In Matlab, <span class="math inline">\(B^{-1}C=\)</span><code>B\C</code> and <span class="math inline">\(B/C^{-1}=\)</span><code>B/C</code>.</li><li>The relationship between <strong>the deconvolution and the inverse of a matrix</strong></li><li><a href="https://en.wikipedia.org/wiki/Toeplitz_matrix" target="_blank" rel="noopener"><strong>Toeplitz matrix</strong></a> and its &quot;upside down&quot; version - <a href="https://en.wikipedia.org/wiki/Hankel_matrix" target="_blank" rel="noopener"><strong>Hankel matrix</strong></a> <span class="math inline">\(\rightarrow\)</span> filter correlation <span class="math inline">\(\rightarrow\)</span> <strong>Transmission line matrix (Waveguide)</strong></li><li><a href="https://en.wikipedia.org/wiki/Vandermonde_matrix" target="_blank" rel="noopener"><strong>VanderMonde matrix</strong></a> <span class="math inline">\(\rightarrow\)</span> damped sin wave (inversion) $nose cancellation</li><li>Matrices might not be inversable just like one might not recover the original signal from its projection onto one axis.</li><li><span class="math inline">\((\mathbf{ABC})^\intercal = \mathbf{C}^\intercal\mathbf{B}^\intercal\mathbf{A}^\intercal\)</span></li><li><a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors" target="_blank" rel="noopener">Eigenvector <span class="math inline">\(\mathbf{v}\)</span> and eigenvalues <span class="math inline">\(\lambda\)</span></a>. &quot;Eigen&quot; origins from German for &quot;proper&quot;.<ul><li><span class="math inline">\(T(\mathbf{v})=\lambda\mathbf{v}\)</span>: <span class="math inline">\(T\)</span> is a linear transform and <span class="math inline">\(\mathbf{v}\)</span> and <span class="math inline">\(\lambda\)</span> are its eigenvector and eigenvalue.</li><li><a href="https://en.wikipedia.org/wiki/Spectrum_of_a_matrix" target="_blank" rel="noopener">The spectrum of a matrix is the set of its eigenvalues</a> and each eigenvector represents one frequency or one dimension/direction. Check <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix" target="_blank" rel="noopener"><strong>Eigendecomposition of a matrix</strong></a>.</li></ul></li></ul><h2 id="functions-and-polynomials">Functions and Polynomials</h2><ul><li>Linear (gain or interpolation), exponential (the feedback loop) and polynomial functions (spline interpolation, harmonic distortion or representing any functions)</li><li>Chebyshev Polynomial and distortion</li><li>Roots of polynomials <span class="math inline">\(p_n(x_i) = 0\)</span><ul><li><code>roots</code> (order limits)</li><li><span class="math inline">\(p_n(x) = (x-x_1)p_{n-1}(x) = a_n\prod_{i=1}^n(x-x_i)\)</span> <strong>??</strong></li></ul></li></ul><h2 id="rational">Rational</h2><ul><li><span class="math inline">\(f(x) = \frac{Q}{P}\)</span></li><li>Filter frequency response is a rational function (for most of cases), e.g., an exception, viscosity loss of pipe <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(\sqrt{f}\)</span> <span class="math inline">\(\rightarrow\)</span> irrational function</li></ul><h2 id="complex-numbers">Complex numbers</h2><h3 id="imaginary">Imaginary</h3><ul><li>Matlab considers a number to be complex (<span class="math inline">\(\mathbb{C}\)</span>)<br></li><li>Complex number is defined because it does not exist in <span class="math inline">\(\mathbb{R}\)</span> or is just not defined before?</li><li><span class="math inline">\(j, -1, -j, 1\)</span> for <span class="math inline">\(j^n\)</span>, where <span class="math inline">\(n=1,2,3,4\)</span>.</li><li>Imaginary, a good word, but <a href="https://www.math.toronto.edu/mathnet/answers/imaginary.html" target="_blank" rel="noopener">imaginary is not real imaginary</a></li></ul><h3 id="phase-and-angle">Phase and angle</h3><ul><li><code>atan2</code>, &quot;2&quot; because it accepts two arguments and <code>angle</code> in Matlab uses <code>atan2</code></li><li>phase in(de)crease infinitely but how?</li></ul><h3 id="conjuage">Conjuage</h3><ul><li><a href="http://www.oed.com/view/Entry/39266?rskey=5nAP9w&amp;result=1&amp;isAdvanced=false#eid" target="_blank" rel="noopener">conjugate</a> meaning the opposite angle</li><li>real coefficients of polynomial <span class="math inline">\(\rightarrow\)</span> roots must be grouped by pairs</li><li>Euler's formula<span class="math inline">\(\rightarrow\)</span></li><li><span class="math inline">\(e^{j\theta} = \cos\theta+j\sin\theta\)</span> where <span class="math inline">\(e^{j\theta}\)</span> is the <a href="https://en.wikipedia.org/wiki/Analytic_signal" target="_blank" rel="noopener">analytic signal</a>, the analytic representation of the real-value function (<a href="https://en.wikipedia.org/wiki/Analytic_continuation" target="_blank" rel="noopener">analytic continuation</a>)</li><li>Transfer complex to real after passing a linear system is true but it is not true for a nonliear processing. <strong>WHY?</strong></li></ul><h3 id="unity-circle">Unity Circle</h3><ul><li>For root of unity <span class="math inline">\(z^N=1\)</span>, there are <span class="math inline">\(N\)</span> Nth root because it is an Nth-order polynomial <span class="math inline">\(1-z^N=0\)</span>.</li><li>Reciprocal of <span class="math inline">\(z\)</span> <span class="math inline">\(\rightarrow\)</span> unit circle (in(out)side) <span class="math inline">\(\rightarrow\)</span> stability ((un)stable)</li><li>polynomial<ul><li><a href="https://en.wikipedia.org/wiki/Complex_conjugate_root_theorem" target="_blank" rel="noopener">Complex conjugate root theorem</a>: real coefficients <span class="math inline">\(\rightarrow\)</span> roots are conjugate pairs.</li><li>symmetrical coefficients <span class="math inline">\(\rightarrow\)</span> roots are conjugate inverse pairs</li><li>when, <span class="math inline">\(|z|=1\)</span>, <span class="math inline">\(z^*=\dfrac{1}{z}\)</span>, roots are pairs of both inverse and conjugate, and are on unit circle.</li></ul></li><li><span class="math inline">\(D(u,v)=\overline{D(v,u)}\)</span></li><li><span class="math inline">\(D(u,v) = \sum_{i=1}^{N}\bar{u}_iv_i=u^{*T}v = u^Hv\)</span>, <span class="math inline">\(H\)</span> means transposed and conjugated <span class="math inline">\(\rightarrow\)</span> <code>u'</code> in Matlab</li><li><code>u.'</code> only does the transpose</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes of Digital Audio Signal Processing, Lecture 2.
    
    </summary>
    
      <category term="DSP" scheme="http://swang251.github.io/categories/DSP/"/>
    
    
      <category term="Lecture Notes (DASP)" scheme="http://swang251.github.io/tags/Lecture-Notes-DASP/"/>
    
  </entry>
  
  <entry>
    <title>Sync your blogs across different OSs in Hexo</title>
    <link href="http://swang251.github.io/2019/01/07/Sync-your-blog-across-different-OSs-in-Hexo/"/>
    <id>http://swang251.github.io/2019/01/07/Sync-your-blog-across-different-OSs-in-Hexo/</id>
    <published>2019-01-07T06:13:04.000Z</published>
    <updated>2019-01-11T22:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is an article about how to synchronize blogs across your different operating systems. <a id="more"></a></p><p>It has been one year since I first set up Hexo and half a year since my first meaningful blog. I think it better to note down the steps I used to set up my GitHub Pages.</p><h2 id="github-pages-hexo-maupassant">GitHub Pages + Hexo + Maupassant</h2><h3 id="github-pages">GitHub Pages</h3><blockquote><p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository.</p></blockquote><ul><li>You would need to create a new repository named &quot;username.github.io&quot;.</li></ul><h3 id="static-generator">Static Generator</h3><p>The static generator would help transform your plain text into static webpages. There are several choices, the most widely used of which are <a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a>, <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> and <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>. I didn't try everything. Instead, I try to read comparison articles online and find the one suit for me. I remember that one of the reasons that Hexo attracts me is its &quot;Blazing Fast&quot;. &gt; <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.</p><h3 id="theme">Theme</h3><p>You might need a theme for your blog and again, there are <a href="https://hexo.io/themes/" target="_blank" rel="noopener">hundreds of options</a>. Finally, I decide to go for <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">Maupassant</a> because it looks concise. &gt; <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">Maupassant</a> - A simple Hexo template with great performance on different devices, ported from a Typecho theme by <a href="https://github.com/pagecho/maupassant" target="_blank" rel="noopener">Cho</a>, forked and modified from <a href="https://github.com/icylogic" target="_blank" rel="noopener">icylogic</a>.</p><h2 id="installation">Installation</h2><ul><li>The setup of Hexo is really simple. I just follow the <a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo Documentation</a> and its done. This would include:<ul><li>Install <a href="https://hexo.io/docs/#Install-Git" target="_blank" rel="noopener">Git</a></li><li>Install <a href="https://hexo.io/docs/#Install-Node-js" target="_blank" rel="noopener">Node.js</a></li><li>Install <a href="https://hexo.io/docs/#Install-Hexo" target="_blank" rel="noopener">Hexo</a></li></ul></li></ul><h2 id="setup">Setup</h2><h3 id="hexo-setup">Hexo Setup</h3><ol type="1"><li>Go to the directory of the GitHub Page repository</li><li><code>hexo init</code>, initialization. Several folders and files would be generated.</li><li><code>npm install</code>, install packages based on <em>package.json</em> generated during <code>hexo init</code>, where <code>npm</code> is short for Node.js package manager. Actually, <code>npm install</code> should already be called during <code>hexo init</code>. (ref. <a href="https://hexo.io/docs/setup" target="_blank" rel="noopener">Hexo Setup</a>, <a href="https://docs.npmjs.com/cli/install.html" target="_blank" rel="noopener">npm-install</a>)</li><li>Follow the way of <a href="https://hexo.io/docs/deployment#Git" target="_blank" rel="noopener">deployment using Git</a>.</li></ol><h3 id="directory-structures">Directory Structures</h3><p>Several folders and files would be generated after <code>hexo init</code></p><ul><li><strong><a href="(https://hexo.io/docs/setup#config-yml)">_config.yml</a></strong>: site <a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">configuration</a> file, where one can configure most settings here</li><li><strong><a href="https://hexo.io/docs/setup#package-json" target="_blank" rel="noopener">package.json</a></strong> and <strong>package-lock.json</strong>: Application data, including the modules you need. The <strong>package-lock.json</strong> is automatically generated for any operations where npm modifies either the node_modules tree, or package.json. It describes the exact tree that was generated, such that subsequent installs are able to generate identical trees, regardless of intermediate dependency updates. (ref. <a href="https://docs.npmjs.com/files/package-lock.json" target="_blank" rel="noopener">npm-package-lock.json</a> and <a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">npm-package.json</a>).</li><li><strong>[node_modules]</strong>: the folder that local modules/packages of Node.js drop into. Its contents should correspond to <strong>package.json</strong> and is generated based on <code>npm install</code></li><li><strong><a href="https://hexo.io/docs/setup#scaffolds" target="_blank" rel="noopener">scaffolds</a></strong>: Seems like a folder for templates.</li><li><strong><a href="https://hexo.io/docs/setup#source" target="_blank" rel="noopener">source</a></strong>: the source folder including the original contents of the site, e.g., your Markdown files.</li><li><strong><a href="https://hexo.io/docs/setup#themes" target="_blank" rel="noopener">themes</a></strong>: the theme folders.</li><li><strong>db.json</strong>: no ideas about it, seems to be generated by <code>hexo generate</code> and is kind of cache which stores all posts, tags, categories, etc. in a JSON format for faster parsing. It would correspond to the generated sites.</li><li><strong>public</strong>: All the static webpage files generated by <code>hexo generate</code> and also the ones deployed to the git repository using <code>hexo-deployer-git</code>.</li><li><strong>.deploy_git</strong>, the folder for deployment of the static pages.</li></ul><h3 id="theme-setup">Theme Setup</h3><ul><li>Follow the installation of the theme <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">Maupassant</a>.</li></ul><h3 id="git-the-whole-blogs-instead-of-the-only-the-static-websites">Git the whole blogs instead of the only the static websites</h3><p>You might have already noticed that using <code>hexo-deployer-git</code>, only the static websites would be git to the GitHub repository and you'll lose everything if your laptop dies without backup. Also, it is hard to synchronize across your multiple computers. So here is how to git everything including the original markdowns using two branches. The is based on this <a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%23more" target="_blank" rel="noopener">article</a> which is 404 now. But you could still refer to his answer in <a href="https://www.zhihu.com/question/21193762/answer/79109280" target="_blank" rel="noopener">知乎</a></p><ol type="1"><li>Create the repository username.github.io</li><li><p>Add the following to .gitignore <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public/</span><br><span class="line">package-lock.json</span><br><span class="line">.deploy_git/</span><br><span class="line">db.json</span><br></pre></td></tr></table></figure></p></li><li>Create two branches: master and hexo.</li><li>Set hexo as the default branch.</li><li>clone the repository and set up based on the instruction above.</li><li><p>set the <code>deploy -&gt; branch</code> in **_config.yml** to master.</p></li></ol><p>This way, the static webpages generated and deployed by <code>hexo g -d</code> would be stored in the master branch which the original markdown files and the configuration would be in hexo branch using <code>git push origin hexo</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is an article about how to synchronize blogs across your different operating systems.
    
    </summary>
    
      <category term="daily" scheme="http://swang251.github.io/categories/daily/"/>
    
    
      <category term="Hexo" scheme="http://swang251.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Adding a Shared Google Calendar to the Calendar App on the Mac</title>
    <link href="http://swang251.github.io/2018/12/30/GoogleCalendarOnMac/"/>
    <id>http://swang251.github.io/2018/12/30/GoogleCalendarOnMac/</id>
    <published>2018-12-30T15:57:19.000Z</published>
    <updated>2018-12-30T17:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>In addition to your own google calendar, which is easy to be added to your Mac Calendar, there might also be some Google calendars shared with you. It would be convenient if they could also be added to your Mac Calendar and here is how.</p><a id="more"></a><p>There are two methods:</p><h3 id="method-1">Method 1:</h3><ol type="1"><li>When you open the link of the calendar shared with you. You could click the plus sign at the right corner to add it into your own google calendar. <img src="/images/20181229/google_calendar_add.png"></li><li>Go to https://www.google.com/calendar/syncselect and check the calendar shared with you.</li><li>Go to the Mac Calendar and you will find it in your calendar list just under your google account. Check it for display.</li></ol><h3 id="method-2">Method 2:</h3><ol type="1"><li>As step 1 in Method 1.</li><li>Go to the Google Calendar and the shared calendar appears in the &quot;Other calendars&quot;, go to the setting of the shared calendar.</li><li>Scroll down and find the &quot;Integrate calendar-&gt;public address in iCal format&quot; and copy the address.</li><li>Open the Mac Calendar and go to &quot;Files -&gt; New Calendar Subscription&quot; and paste the address into the &quot;Calendar URL&quot;.</li></ol><p>PS: Also answered in <a href="https://apple.stackexchange.com/a/347044/222234}</p>" target="_blank" rel="noopener">StackExchange</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;In addition to your own google calendar, which is easy to be added to your Mac Calendar, there might also be some Google calendars shared with you. It would be convenient if they could also be added to your Mac Calendar and here is how.&lt;/p&gt;
    
    </summary>
    
      <category term="daily" scheme="http://swang251.github.io/categories/daily/"/>
    
    
      <category term="MacOS" scheme="http://swang251.github.io/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>DSP First - Chapter 2 - Sinusoids</title>
    <link href="http://swang251.github.io/2018/12/19/DSPFirst-Ch2/"/>
    <id>http://swang251.github.io/2018/12/19/DSPFirst-Ch2/</id>
    <published>2018-12-19T16:11:09.000Z</published>
    <updated>2018-12-30T01:08:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Sinusoids, or sinusoidal signals, representing the cosine or sine signals/waves, are the most basic signals in the theory of signals and systems. This chapter introduces the basic sinusoid concepts and operations.</p><a id="more"></a><h3 id="sinusoidal-signals">Sinusoidal signals</h3><ul><li>The general mathematical formula for a cosine signal is <span class="math display">\[\begin{equation} x(t) = A\cos(\omega_0 t + \phi) = A\cos(2\pi f_0 t + \phi), \end{equation}\label{cos}\]</span> where<ul><li><span class="math inline">\(A\)</span> is the amplitude,</li><li><span class="math inline">\(\omega_0\)</span> is the radian frequency (rad/sec),</li><li><span class="math inline">\(\phi\)</span> represents the radian phase-shift (rads),</li><li><span class="math inline">\(f_0 = \omega_0/2\pi\)</span>, the cyclic frequency (sec<span class="math inline">\(^{-1}\)</span>), represents the number of periods (cycles) per second,</li><li><span class="math inline">\(T_0 = \dfrac{1}{f_0} = \dfrac{2\pi}{\omega_0}\)</span>, the period (sec), is the one cycle length of the sinusoid in time.</li></ul></li><li>Phase shift and time shift<ul><li>Having <span class="math inline">\(x_1(t) = x(t-t_1)\)</span>, we say <span class="math inline">\(x(t)\)</span> is a time-shifted version of <span class="math inline">\(s(t)\)</span><ul><li>if <span class="math inline">\(t_1 &gt; 0\)</span>, shifted to the right = delayed,</li><li>if <span class="math inline">\(t_1 &lt; 0\)</span>, shifted to the left = advanced.</li></ul></li><li>Taking the sinusoid as the form in Eq. <span class="math inline">\(\eqref{cos}\)</span>,<ul><li>convert time shift to a phase shift: <span class="math inline">\(x(t-t_1) = A\cos(\omega_0(t-t_1)+\phi) = A\cos(\omega_0t+\phi+\phi_1)\)</span>, where <span class="math inline">\(\phi_1 = -\omega_0t_1\)</span> is the phase shift.</li><li><span class="math inline">\(t_1 = -\dfrac{\phi}{\omega_0} = -\dfrac{\phi}{2\pi f_0}\)</span>,</li><li><span class="math inline">\(\phi_1 = -2\pi f_0 t_1 = -2\pi\dfrac{t_1}{T_0}\)</span>.</li></ul></li><li>Based on the definition of the time shift and the phase shift, <strong>they have the opposite direction</strong>, e.g., if the time shift is positive (delay), the phase shift would be negative.</li></ul></li></ul><h3 id="complex-exponentials-and-phasors">Complex exponentials and phasors</h3><h4 id="complex-exponentials">Complex exponentials</h4><ul><li>Complex exponentials provide an alternative representation for the real cosine signal and might make things easier: <span class="math display">\[\begin{equation}\bar{x}(t) = Ae^{j(\omega_0t + \phi)}\end{equation} \label{complex} \]</span><ul><li><span class="math inline">\(x(t) = \Re{\{Ae^{j(\omega_0t+\phi)}\}} = A\cos(\omega_0t+\phi)\)</span></li></ul></li></ul><h4 id="phasors">Phasors</h4><ul><li>The rotating phasor interpretation<ul><li>The complex exponential signal could be expressed as <span class="math inline">\(\bar{x}(t)=Xe^{j\omega_0t}\)</span>, i.e., the product of the complex amplitude <span class="math inline">\(X=Ae^{j\phi}\)</span> and the complex-valued function <span class="math inline">\(e^{j\omega_0t}\)</span>.</li><li>The complex amplitude <span class="math inline">\(X\)</span> is also called the <strong>phasor</strong>.</li><li><span class="math inline">\(\bar{x}(t)=Xe^{j\omega_0t}=Ae^{j\theta(t)}\)</span>, where <span class="math inline">\(\theta(t) = \omega_0t + \phi\)</span>.</li><li>In the complex plane, <span class="math inline">\(\bar{x}(t)\)</span> is simply a rotating vector at a constant rate <span class="math inline">\(\omega_0\)</span> with initial phase <span class="math inline">\(\phi\)</span> (<span class="math inline">\(t=0\)</span>). So a complex exponential signal is a <strong>rotating phasor</strong>.<ul><li><span class="math inline">\(\omega_0 &gt; 0\)</span>: rotating counterclockwise,</li><li><span class="math inline">\(\omega_0 &lt; 0\)</span>: rotating clockwise.</li></ul></li></ul></li><li><p>Applying the inverse Euler's formula, the real cosine signal with radian frequency <span class="math inline">\(\omega_0\)</span> is composed of two conjugated complex exponential signals with frequencies of <span class="math inline">\(\omega_0\)</span> and <span class="math inline">\(-\omega_0\)</span>, and also complex amplitudes of <span class="math inline">\(\frac{1}{2}Ae^{j\phi}\)</span> and <span class="math inline">\(-\frac{1}{2}Ae^{j\phi}\)</span>, respectively. <span class="math display">\[x(t) = A\cos(\omega_0t+\phi) = \frac{1}{2}\bar{x}(t) + \frac{1}{2}\bar{x}^*(t) = \Re{\{\bar{x}(t)\}}\]</span></p></li><li>Phasor Addition (additions of sinusoids with the same frequency but different amplitudes and phases)<ul><li>Phasor addition rule: <em>The summation of sinusoids with the same frequency is a sinusoid with the identical frequency with the amplitude and phase of a certain phasor calculated by the summation of the phasors of each sinusoid.</em></li><li>Summation of phasors is also a phasor: <span class="math display">\[\begin{equation}  \sum_{k=1}^N A_ke^{j\phi_k} = Ae^{j\phi}  \end{equation} \label{phasor_sum}\]</span></li><li>Finally, lead us to: <span class="math display">\[\sum_{k=1}^N A_k\cos(\omega_0t + \phi_k) = A\cos(\omega_0t + \phi)\]</span> which could be proved either by<ul><li>trigonometric identities, or</li><li>summation of phasors following the steps:<ol type="1"><li>Get the phasors <span class="math inline">\(X_k = A_ke^{j\phi_k}\)</span> of each individual cosine signals,</li><li>Add phasors using Eq. <span class="math inline">\(\eqref{phasor_sum}\)</span>, employing polar-to-Cartesian-to-polar conversion,</li><li>Multiply the resulting phasor <span class="math inline">\(X=Ae^{j\phi}\)</span> with the rotating function <span class="math inline">\(e^{j\omega_0t}\)</span> and get <span class="math inline">\(\bar{x}(t)\)</span>,</li><li>Take the real part and get <span class="math inline">\(x(t) = \bar{x}(t)\)</span>.</li></ol></li></ul></li></ul></li></ul><h3 id="review-of-sine-and-cosine-functions">Review of sine and cosine functions</h3><h4 id="properties">Properties</h4><ul><li>Equivalence: <span class="math inline">\(\sin\theta = \cos(\theta-\pi/2)\)</span> or <span class="math inline">\(\cos\theta=\sin(\theta+\pi/2)\)</span>; <strong>the sine function is just a cosine function that is shifted to the right by <span class="math inline">\(\pi/2\)</span></strong>,</li><li>Periodicity: <span class="math inline">\(\cos(\theta + 2\pi k) = \cos\theta\)</span>, where <span class="math inline">\(k\in \mathbb{Z}\)</span>,</li><li>Evenness of cosine: <span class="math inline">\(\cos(-\theta) = \cos\theta\)</span>,</li><li>Oddness of sine: <span class="math inline">\(\sin(-\theta) = -\sin\theta\)</span>,</li><li>Zeros of sine: <span class="math inline">\(\sin(\pi k) = 0\)</span>, for <span class="math inline">\(k\in\mathbb{Z}\)</span>,</li><li>Ones of sine: <span class="math inline">\(\cos(2\pi k) = 1\)</span>, for <span class="math inline">\(k\in\mathbb{Z}\)</span>,</li><li>Minus ones of cosine: <span class="math inline">\(\cos[2\pi(k+\dfrac{1}{2})]=-1\)</span>, for <span class="math inline">\(k\in\mathbb{Z}\)</span>,x</li><li>Derivatives: <span class="math inline">\(\dfrac{d \sin\theta}{d \theta} = \cos\theta\)</span> and <span class="math inline">\(\dfrac{d \cos\theta}{d \theta} = -\sin\theta\)</span>.</li></ul><h4 id="trigonometric-identities">Trigonometric identities</h4><ul><li><span class="math inline">\(\sin^2\theta + \cos^2\theta = 1\)</span>,</li><li><span class="math inline">\(\cos^2\theta = \cos^2\theta - \sin^2\theta\)</span>,</li><li><span class="math inline">\(\sin^2\theta = 2\sin\theta\cos\theta\)</span>,</li><li><span class="math inline">\(\sin(\alpha\pm\beta) = \sin\alpha\cos\beta \pm \cos\alpha\sin\beta\)</span>,</li><li><span class="math inline">\(\cos(\alpha\pm\beta) = \cos\alpha\cos\beta \mp \sin\alpha\sin\beta\)</span>,</li><li><span class="math inline">\(\cos^2\theta = \frac{1}{2}(1+\cos 2\theta)\)</span>,</li><li><span class="math inline">\(\sin^2\theta = \frac{1}{2}(1-\cos 2\theta)\)</span>.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sinusoids, or sinusoidal signals, representing the cosine or sine signals/waves, are the most basic signals in the theory of signals and systems. This chapter introduces the basic sinusoid concepts and operations.&lt;/p&gt;
    
    </summary>
    
      <category term="DSP" scheme="http://swang251.github.io/categories/DSP/"/>
    
    
      <category term="DSP First" scheme="http://swang251.github.io/tags/DSP-First/"/>
    
  </entry>
  
  <entry>
    <title>DSP First - Appendix A - Complex Numbers</title>
    <link href="http://swang251.github.io/2018/12/18/DSPFirst-AppendixA/"/>
    <id>http://swang251.github.io/2018/12/18/DSPFirst-AppendixA/</id>
    <published>2018-12-19T03:18:05.000Z</published>
    <updated>2019-01-22T22:13:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>In this appendix, the basic manipulations of complex numbers are reviewed. There ideas are treated:<ul><li>simple algebraic rules: operations on <span class="math inline">\(z = x+jy\)</span>.</li><li>elimination of trigonometry: Euler's formula for the complex exponential <span class="math inline">\(z = re^{j\theta}=r\cos\theta+jr\sin\theta\)</span>.</li><li>representation by vectors: a way for visualization.</li></ul></li><li>Symbol: <span class="math inline">\(i\)</span> or <span class="math inline">\(j\)</span><ul><li>Physicists and mathematicians use symbol <span class="math inline">\(i=\sqrt{-1}\)</span>.</li><li>Electrical engineers use symbol <span class="math inline">\(j=\sqrt{-1}\)</span> instead because <span class="math inline">\(i\)</span> is left to the current.</li></ul></li><li>Algebraic vs. Trigonometric vs. Geometric.</li></ul><h3 id="a.1-introduction">A.1 Introduction</h3><ul><li>The way <span class="math inline">\(j\)</span> is introduced: <span class="math inline">\(z^2=-1\)</span> ==&gt; <span class="math inline">\(z=\pm j\)</span>.</li><li>More general, complex numbers are the roots of quadratic equations.</li></ul><h3 id="a.2-notation-for-complex-numbers">A.2 Notation for complex numbers</h3><ul><li>There are two types complex number representations:<ul><li>Rectangular form (Cartesian form): <span class="math inline">\(z = (x, y) = x + jy = \Re \{ z \} + j\Im\{z\}\)</span>, where <span class="math inline">\(\Re\{\}\)</span> and <span class="math inline">\(\Im\{\}\)</span> represent the real and imaginary parts of the complex number, respectively.</li><li>Polar form: <span class="math inline">\(z \leftrightarrow r\angle\theta\)</span> where <span class="math inline">\(r\)</span> is the amplitude and <span class="math inline">\(\angle\theta\)</span> is the angle whose principal value belongs to <span class="math inline">\(-180^{\circ}&lt;\theta &lt; 180^{\circ}\)</span></li><li>Conversion:<ul><li>polar --&gt; rectangular: <span class="math inline">\(z=x + jy\)</span>, where <span class="math display">\[\begin{equation}      \begin{cases}      x = r\cos\theta,\\      y = r\sin\theta      \end{cases} \end{equation}   \label{eq1}\]</span></li><li>rectangular --&gt; polar: <span class="math inline">\(z = re^{j\theta}=|z|e^{j\, \text{arg}|z|}\)</span>, where <span class="math display">\[\begin{equation}      \begin{cases}      r = \sqrt{x^2+y^2},\\      \theta = \text{atan}(y, x)      \end{cases} \end{equation}   \label{eq2}\]</span></li></ul></li></ul></li></ul><h3 id="a.3-eulers-formula">A.3 Euler's formula</h3><ul><li>Euler's formula <span class="math display">\[ \begin{equation} e^{j\theta} = \cos{\theta} + j\sin\theta \end{equation}\label{Euler} \]</span></li><li>Inverse Euler fomulas <span class="math display">\[ \begin{align}    \cos\theta &amp;= \frac{e^{j\theta} + e^{-j\theta}}{2}\\    \sin\theta &amp;= \frac{e^{j\theta} - e^{-j\theta}}{2} \end{align}\]</span></li></ul><h3 id="a.4-algebraic-rules-for-complex-numbers">A.4 Algebraic rules for complex numbers</h3><h4 id="rectangular-form">Rectangular form</h4><p>For <span class="math inline">\(z_1 = x_1 + jy_1\)</span> and <span class="math inline">\(z_2 = x_2+jy_2\)</span>,</p><ul><li>addition and subtraction: <span class="math inline">\(z_1 \pm z_2 = (x_1 \pm x_2) + j(y_1 \pm y_2)\)</span>.</li><li>multiplication: <span class="math inline">\(z_1 z_2 = (x_1 x_2-y_1 y_2)+j(x_1 y_2+x_2 y_1)\)</span></li><li>conjugate: <span class="math inline">\(z_1^* = x_1 - jy_1\)</span></li><li>division: <span class="math inline">\(\dfrac{z_1}{z_2} = \dfrac{z_1z_2^*}{z_2z_2^*} = \dfrac{z_1z_2^*}{|z_2|^2} = \dfrac{(x_1x_2+y_1y_2) + j(x_2y_1-x_1y_2)}{x_2^2+y_2^2}\)</span></li></ul><h4 id="polar-form">Polar form</h4><p>For <span class="math inline">\(z_1 = r_1e^{j\theta_1}\)</span> and <span class="math inline">\(z_2 = r_2e^{j\theta_2}\)</span>,</p><ul><li>multiplication: <span class="math inline">\(z_1z_2 = (r_1r_2)e^{j(\theta_1+theta_2)}\)</span></li><li>conjugate: <span class="math inline">\(z_1^* = r_1e^{-j\theta_1}\)</span></li><li>division: <span class="math inline">\(\dfrac{z_1}{z_2} = \dfrac{r_1}{r_2}e^{j(\theta_1-\theta_2)}\)</span></li><li>addition and subtraction: transfer to rectangular form and do the addition or subtraction, and then, transfer back to polar form.</li></ul><h4 id="others">others</h4><ul><li><span class="math inline">\(\Re\{z\} = \dfrac{z+z^*}{2}\)</span></li><li><span class="math inline">\(\Im\{z\} = \dfrac{z-z^*}{2j}\)</span></li><li><span class="math inline">\(|z|^2 = zz^*\)</span></li></ul><h3 id="a.5-geometric-views-off-complex-operations">A.5 Geometric views off complex operations</h3><p>A geometric view provides a convenient visualization for complex number operations.</p><h3 id="a.6-powers-and-roots">A.6 Powers and Roots</h3><ul><li><span class="math inline">\(z^N = (re^{j\theta})^N = r^Ne^{jN\theta}\)</span></li><li>De Moivre's formula: <span class="math inline">\((\cos\theta + j\sin\theta)^N = \cos N\theta + j\sin N\theta\)</span> (because <span class="math inline">\((e^{j\theta})^N = e^{jN\theta}\)</span>)</li><li>Roots of unity (<span class="math inline">\(z^N=1\)</span>): <span class="math inline">\(z=e^{j2\pi l/N}\)</span> for <span class="math inline">\(l=0,1,2\dots N-1\)</span></li><li><span class="math inline">\(z^N=c=|c|e^{j\phi}\)</span>: <span class="math inline">\(z=re^{j\theta}\)</span>, where <span class="math display">\[\begin{cases}r = |c|^{1/N},\\\theta = \dfrac{\phi+2\pi l}{N},\end{cases}\]</span> and <span class="math inline">\(\theta\)</span> is the angular spacing.</li></ul><!-- the famous matter-energy equation $\eqref{eq1}$ proposed by Einstein ...-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;In this appendix, the basic manipulations of complex numbers are reviewed. There ideas are treated:
&lt;ul&gt;
&lt;li&gt;simple algebraic rules
      
    
    </summary>
    
      <category term="DSP" scheme="http://swang251.github.io/categories/DSP/"/>
    
    
      <category term="DSP First" scheme="http://swang251.github.io/tags/DSP-First/"/>
    
  </entry>
  
  <entry>
    <title>DSP First - Chapter 1 - Introduction</title>
    <link href="http://swang251.github.io/2018/12/17/DSPFirst-Ch1/"/>
    <id>http://swang251.github.io/2018/12/17/DSPFirst-Ch1/</id>
    <published>2018-12-17T23:12:37.000Z</published>
    <updated>2018-12-30T01:12:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Just got the TA position for the lecture <em>Digital Audio Signal Processing</em>. It is a class introducing the basic digital audio signal processing. Even so, I thought it better to prepare more for the lecture. So I decided to review the reference book <em>DSP FIRST - A multimedia Approach</em> during the break.</p><p>The contents in the book are well-structured and well-explained, and there is nothing tricky inside. All we need to do is to review and use it again and again to make it a solid in our mind. In the blogs, there is nothing else but a list of the key points presented in the book but hopefully, this could help me strengthen my understanding.</p><a id="more"></a><ul><li>This is a book about signals and systems.</li><li>A signal is something that carries information and the system is something that operates the signals.</li><li>In the other <a href="https://www.dspguide.com/ch5/1.htm" target="_blank" rel="noopener">book</a>: A signal is a description of how one parameter varies with another parameter. For instance, the voltage changing over time in an electronic circuit, or brightness varying with distance in an image. A system is any process that produces an output signal in response to an input signal.</li></ul><h4 id="mathematical-representation-of-signals">1.1 Mathematical representation of signals</h4><ul><li><span class="math inline">\(s(t)\)</span>: the continuous signal</li><li><span class="math inline">\(s[n] = s(nT_s)\)</span>: the discrete-time signal, where <span class="math inline">\(T_s\)</span> is the sampling period.</li><li>Same for the image: <span class="math inline">\(p(x,y) \rightarrow p(m\Delta x, n\Delta y) = p[m, n]\)</span></li></ul><h4 id="mathematical-representation-of-systems">1.2 Mathematical representation of systems</h4><ul><li>A system is something that transform signals into new signals or different signal representations: <span class="math inline">\(y(t) = \mathcal{T}\{x(t)\}\)</span> where the system is represented by the operation <span class="math inline">\(\mathcal{T}\{\}\)</span>.</li><li>block diagram: a way for the visualization to represent operations and to show the interrelations among the signals.</li></ul><blockquote><p>A block diagram is a diagram of a system in which the principal parts or functions are represented by blocks connected by lines that show the relationships of the blocks. (from <a href="https://en.wikipedia.org/wiki/Block_diagram" target="_blank" rel="noopener">wiki</a>)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Just got the TA position for the lecture &lt;em&gt;Digital Audio Signal Processing&lt;/em&gt;. It is a class introducing the basic digital audio signal processing. Even so, I thought it better to prepare more for the lecture. So I decided to review the reference book &lt;em&gt;DSP FIRST - A multimedia Approach&lt;/em&gt; during the break.&lt;/p&gt;
&lt;p&gt;The contents in the book are well-structured and well-explained, and there is nothing tricky inside. All we need to do is to review and use it again and again to make it a solid in our mind. In the blogs, there is nothing else but a list of the key points presented in the book but hopefully, this could help me strengthen my understanding.&lt;/p&gt;
    
    </summary>
    
      <category term="DSP" scheme="http://swang251.github.io/categories/DSP/"/>
    
    
      <category term="DSP First" scheme="http://swang251.github.io/tags/DSP-First/"/>
    
  </entry>
  
</feed>
